<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>CustosEye · Live</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link rel="icon" href="/static/assets/favicon.ico?v=2">
  <link rel="icon" type="image/png" sizes="32x32" href="/static/assets/favicon-32x32.png?v=2">
  <link rel="icon" type="image/png" sizes="16x16" href="/static/assets/favicon-16x16.png?v=2">
  <link rel="apple-touch-icon" href="/static/assets/apple-touch-icon.png?v=2">
  <style>
    :root {
      --bg:#0b0f14; --panel:#141a22; --text:#e7eef7; --muted:#9ab;
      --chip-info:#2a6df1; --chip-warning:#e6a700; --chip-critical:#d43c3c; --chip-border:rgba(255,255,255,0.2);
      --accent:#7cc5ff; --ok:#1db954; --border:#1f2a36; --row:#10161e; --rowAlt:#0d131a; --input:#0f141b;
      --tab:#0f151d; --tabOn:#1b2634;
      --trust-low:#c03d3d; --trust-medium:#c27b00; --trust-high:#1db954;
      --bad:#c03d3d; --warn:#e6a700; --good:#1db954;
    }
    @media (prefers-color-scheme: light) {
      :root {
        --bg:#f6f8fb; --panel:#fff; --text:#10131a; --muted:#445;
        --chip-info:#2a6df1; --chip-warning:#c27b00; --chip-critical:#b61e1e; --chip-border:rgba(0,0,0,0.15);
        --accent:#1565c0; --ok:#128b3a; --border:#e7ebf0; --row:#fff; --rowAlt:#f8fafc; --input:#f3f6fa;
        --tab:#f1f4f8; --tabOn:#e5ebf3;
      }
    }
    * { box-sizing: border-box; }
    body { margin:0; background:var(--bg); color:var(--text); font:14px/1.45 -apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Arial; }
    header { position:sticky; top:0; z-index:5; backdrop-filter: blur(6px); background:linear-gradient(180deg,rgba(0,0,0,0.2),transparent); border-bottom:1px solid var(--border); }
    .wrap { max-width:1100px; margin:0 auto; padding:16px; }
    .title { display:flex; align-items:center; gap:10px; margin:4px 0 10px; font-weight:700; letter-spacing:.2px; font-size:18px; }
    .subtitle { color:var(--muted); font-size:12px; }
    .panel { background:var(--panel); border:1px solid var(--border); border-radius:12px; padding:12px; box-shadow:0 6px 20px rgba(0,0,0,0.15); }
    .tabs { display:flex; gap:8px; margin-bottom:10px; }
    .tab { background:var(--tab); border:1px solid var(--border); border-radius:8px; padding:6px 10px; cursor:pointer; user-select:none; }
    .tab.on { background:var(--tabOn); border-color:var(--accent); }
    .controls { display:flex; flex-wrap:wrap; gap:10px; align-items:center; }
    .chip { display:inline-flex; align-items:center; gap:6px; border:1px solid var(--chip-border); padding:4px 10px; border-radius:999px; font-size:12px; cursor:pointer; user-select:none; background:transparent; color:var(--text); }
    .chip[data-on="true"] { background:rgba(124,197,255,0.1); border-color:var(--accent); }
    .chip .dot { width:8px; height:8px; border-radius:999px; }
    .chip.info .dot { background:var(--chip-info); }
    .chip.warning .dot { background:var(--chip-warning); }
    .chip.critical .dot { background:var(--chip-critical); }
    .chip.ok .dot { background:var(--ok); }
    .input { background:var(--input); border:1px solid var(--border); padding:8px 10px; border-radius:8px; color:var(--text); min-width:220px; }
    .btn { background:var(--accent); color:white; border:0; padding:8px 12px; border-radius:8px; cursor:pointer; }
    .list { margin-top:12px; border-top:1px dashed var(--border); }
    .row { display:grid; grid-template-columns:108px 100px 1fr; gap:14px; padding:10px 4px; border-bottom:1px solid var(--border); background:var(--row); }
    .row:nth-child(odd) { background:var(--rowAlt); }
    .lvl { display:inline-flex; align-items:center; gap:8px; padding:4px 8px; border-radius:999px; font-weight:600; letter-spacing:.3px; }
    .lvl.info {
      color: var(--chip-info);
      background: rgba(42,109,241,.14); /* fallback */
      background: color-mix(in oklab, var(--chip-info) 14%, transparent);
    }
    .lvl.warning {
      color: var(--chip-warning);
      background: rgba(230,167,0,.18);  /* fallback */
      background: color-mix(in oklab, var(--chip-warning) 18%, transparent);
    }
    .lvl.critical {
      color: var(--chip-critical);
      background: rgba(212,60,60,.18);  /* fallback */
      background: color-mix(in oklab, var(--chip-critical) 18%, transparent);
    }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; font-size:12px; }
    .muted { color:var(--muted); }
    .count { font-weight:600; }
    .nowrap { white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }

    /* process tree */
    .tree { margin-top:12px; }
    .treebar { display:flex; gap:8px; align-items:center; margin-bottom:8px; }
    .pill { display:inline-block; padding:2px 6px; border-radius:999px; border:1px solid var(--border); font-size:11px; }
    .pill.low { color: var(--trust-low); border-color: color-mix(in oklab, var(--trust-low) 40%, var(--border)); }
    .pill.medium { color: var(--trust-medium); border-color: color-mix(in oklab, var(--trust-medium) 40%, var(--border)); }
    .pill.high { color: var(--trust-high); border-color: color-mix(in oklab, var(--trust-high) 40%, var(--border)); }
    details { border-left:2px solid var(--border); margin-left:10px; padding-left:8px; }
    details > summary { list-style: none; cursor: pointer; }
    summary::-webkit-details-marker { display:none; }
    .caret { display:inline-block; width:0; height:0; border-top:6px solid transparent; border-bottom:6px solid transparent; border-left:6px solid var(--muted); margin-right:6px; transform: translateY(1px) rotate(-90deg); transition: transform .15s ease; }
    details[open] > summary .caret { transform: translateY(1px) rotate(0deg); }

    /* integrity tab */
    .grid { display:grid; gap:10px; grid-template-columns: 1fr; }
    .card { background:var(--panel); border:1px solid var(--border); border-radius:12px; padding:12px; }
    .tbl { width:100%; border-collapse: collapse; border-bottom:1px solid var(--border); }
    .tbl tbody tr:last-child td { border-bottom:none; } /* avoid a double line */
    .tbl th, .tbl td { padding:8px; border-bottom:1px solid var(--border); text-align:left; font-size:12px; }
    .badge { display:inline-block; padding:2px 8px; border-radius:999px; border:1px solid var(--border); font-size:11px; }
    .badge.ok { color:var(--good); border-color: color-mix(in oklab, var(--good) 40%, var(--border)); }
    .badge.warn { color:var(--warn); border-color: color-mix(in oklab, var(--warn) 40%, var(--border)); }
    .badge.bad { color:var(--bad); border-color: color-mix(in oklab, var(--bad) 40%, var(--border)); }
    .small { font-size:11px; color:var(--muted); }
    .hint { color:var(--muted); font-size:12px; }

    /* Keep the table inside its card */
    .tbl { table-layout: fixed; width: 100%; }

    /* Column sizing (adjust to taste) */
    .tbl th:nth-child(1), .tbl td:nth-child(1) { width: 32%; } /* Path */
    .tbl th:nth-child(2), .tbl td:nth-child(2) { width: 10%; } /* Rule */
    .tbl th:nth-child(3), .tbl td:nth-child(3) { width: 34%; } /* Baseline */
    .tbl th:nth-child(4), .tbl td:nth-child(4) { width: 8%;  } /* Last result */
    .tbl th:nth-child(5), .tbl td:nth-child(5) { width: 16%; } /* Actions */
    .row-actions { display:flex; flex-wrap:wrap; gap:8px; max-width:100%; }
    .row-actions .btn { white-space:nowrap; }
    .tbl th, .tbl td { vertical-align: top; overflow: hidden; text-overflow: ellipsis; }
    /* Allow buttons to wrap without being clipped */
    .tbl td:nth-child(5) { overflow: visible; }
    /* Give Actions a floor so it never collapses too small */
    .tbl td:nth-child(5) { min-width: 110px; position: relative; }

    /* Keep integrity header visible while scrolling */
    .tbl thead th { position: sticky; top: 0; background: var(--panel); z-index: 1; }

    @media (max-width: 760px) {
     .row-actions .btn { padding: 6px 8px; font-size: 11px; }
    }

    /* Slightly tighten button spacing on very small widths */
    @media (max-width: 560px) {
    .row-actions { gap: 6px; }
    }

    /* Let controls in the Integrity table expand beyond the rounded clip */
    .grid .card.allow-overflow { overflow: visible; }

    /* Remove the table's extra bottom rule so nothing sticks out */
    .tbl { border-bottom: 0; }

    /* Put a divider above the integrity hint */
    .tbl + .hint {
    border-top: 1px solid var(--border);
    margin-top: 8px;
    padding-top: 8px;
    }

    /* Baseline cell as a small vertical stack */
    .baseline {
    display: flex;
    flex-direction: column;
    gap: 2px;
    }

    /* Full hash should wrap; allow breaks anywhere for long strings */
    .baseline-cell { overflow: visible; }
    .mono-wrap { overflow-wrap: anywhere; word-break: break-word; white-space: normal; }

    /* Status cell: badge on first line, note on second */
    .status {
    display: flex;
    flex-direction: column;
    gap: 2px;
    align-items: flex-start;
    }

    /* Disabled button styles */
    .btn[aria-busy="true"],
    .btn:disabled {
      opacity: .6;
      cursor: not-allowed;
    }
    
    /* Clear focus styles for keyboard users */
    .tab:focus-visible,
    .btn:focus-visible,
    .input:focus-visible {
      outline: 2px solid var(--accent);
      outline-offset: 2px;
      border-radius: 8px;
    }

    /* --- Tooltips --- */
    .tooltip {
    position: fixed;
    z-index: 9999;
    max-width: 280px;
    padding: 6px 8px;
    border-radius: 8px;
    font-size: 12px;
    line-height: 1.3;
    background: color-mix(in oklab, var(--panel) 80%, #000);
    color: var(--text);
    border: 1px solid var(--border);
    box-shadow: 0 6px 16px rgba(0,0,0,.25);
    pointer-events: none;
    opacity: 0;
    transform: translateY(-2px);
    transition: opacity .12s ease, transform .12s ease;
    }
    .tooltip[data-show="true"] {
    opacity: 1;
    transform: translateY(0);
    }
    @media (prefers-reduced-motion: reduce) {
    .tooltip { transition: none; }
    }

    /* Center the Actions column buttons */
    .tbl td:nth-child(5) {                /* the Actions cell */
      vertical-align: middle;             /* override the global 'top' */
    }

    .tbl td:nth-child(5) .row-actions {   /* the container holding the buttons */
      display: flex;
      flex-direction: column;             /* stack buttons */
      align-items: center;                /* center horizontally */
      justify-content: center;            /* center vertically in the cell */
      gap: 8px;
      margin: 0 auto;                     /* keeps it centered if the cell grows */
    }

    /* Optional: uniform button width for a tidier column */
    .tbl td:nth-child(5) .row-actions .btn {
      width: 140px;                       /* adjust to taste */
      text-align: center;
    }
    
    /* Ensure tooltips appear above the header */
    header { z-index: 20; }
    .tooltip { z-index: 9999; }

    /* On narrow screens, go horizontal so it doesn't get too tall */
    @media (max-width: 760px) {
      .tbl td:nth-child(5) .row-actions {
        flex-direction: row;
        flex-wrap: wrap;
        justify-content: center;
      }
    }

    /* Center the Actions column header */
    .tbl th:nth-child(5) { text-align: center; }

    /* Keep action buttons tidy and wrap-friendly */
    .row-actions .btn {
      max-width: 160px;
      white-space: normal;
    }
  </style>
</head>
<body>
  <header>
    <div class="wrap">
      <div class="title">
        <img src="/favicon.ico" alt="" style="width:20px;height:20px;border-radius:4px;opacity:.9" />
        CustosEye <span class="subtitle">local dashboard</span>
      </div>

      <!-- tabs -->
      <div class="tabs" role="tablist">
        <div class="tab on" id="tab-live"      data-tab="live"      data-tip="View live events stream" role="tab" aria-selected="true"  tabindex="0">Live Events</div>
        <div class="tab"     id="tab-tree"      data-tab="tree"      data-tip="Inspect the process tree with trust labels"              role="tab" aria-selected="false" tabindex="-1">Process Tree</div>
        <div class="tab"     id="tab-integrity" data-tab="integrity" data-tip="Watch files for tamper (hash or mtime+size)"             role="tab" aria-selected="false" tabindex="-1">Integrity</div>
        <div class="tab"     id="tab-about"     data-tab="about"     data-tip="Build info and buffer capacity"                          role="tab" aria-selected="false" tabindex="-1">About</div>
      </div>

        <!-- Live bar -->
      <div class="panel" id="bar-live" role="tabpanel" aria-labelledby="tab-live">
        <div class="controls">
          <button class="chip info"     data-on="true"  data-level="info"     data-tip="Toggle Info events"><span class="dot"></span>Info</button>
          <button class="chip warning"  data-on="true"  data-level="warning"  data-tip="Toggle Warnings"><span class="dot"></span>Warning</button>
          <button class="chip critical" data-on="true"  data-level="critical" data-tip="Toggle Critical"><span class="dot"></span>Critical</button>
          <button class="chip ok" id="pause" data-on="false" data-tip="Pause or resume background updates"><span class="dot"></span><span id="pauseText">Live</span></button>
          <input id="search" class="input" placeholder="Search: reason, source, name, pid..." data-tip="Filter visible rows by text" />
          <button class="btn" id="refresh" data-tip="Force an immediate refresh">Refresh</button>
          <select id="exportFmt" class="input" aria-label="Export format" style="min-width:110px">
            <option value="csv">CSV</option>
            <option value="json">JSON</option>
            <option value="jsonl">JSONL</option>
            <option value="xlsx">XLSX</option>
          </select>
          <button class="btn" id="export"  data-tip="Export current view">Export</button>
          <div class="muted">Showing <span id="count" class="count">0</span> / <span id="total" class="count">0</span></div>
          <span id="countStatus" role="status" style="position:absolute;left:-9999px;top:auto;width:1px;height:1px;overflow:hidden;">
          </span>
        </div>
       </div>

      <!-- Integrity bar -->
      <div class="panel" id="bar-integrity" role="tabpanel" aria-labelledby="tab-integrity" style="display:none">
        <div class="grid">
          <div class="card">
            <div class="controls" style="gap:8px">
            <button class="btn" id="i-browse" data-tip="Pick a file (File Explorer)">Browse (Windows)</button>
            <input id="i-path" class="input" placeholder="File path (or use Browse)" style="min-width:360px" data-tip="Target file to watch" />
            <select id="i-rule" class="input" style="min-width:160px" data-tip="Choose exact hash or mtime+size rule">
                <option value="sha256">Exact SHA-256</option>
                <option value="mtime+size">mtime + size</option>
            </select>
            <input id="i-note" class="input" placeholder="Note (optional)" style="min-width:200px" data-tip="Optional label for the target" />
            <button class="btn" id="i-hash" data-tip="Compute a preview hash/attributes">Hash Now</button>
            <button class="btn" id="i-add"  data-tip="Save target to the watch list">Save</button>
            <span class="hint" id="i-hint" aria-live="polite"></span>
            </div>
            <div class="small" id="i-preview" aria-live="polite"></div>
          </div>
          <div class="card allow-overflow">
            <table class="tbl" id="i-table">
              <thead>
                <tr>
                  <th>Path</th>
                  <th>Rule</th>
                  <th>Baseline</th>
                  <th>Last result</th>
                  <th>Actions</th>
                </tr>
              </thead>
              <tbody id="i-tbody"></tbody>
            </table>
            <div class="hint">Targets are stored in <span class="mono">data/integrity_targets.json</span> and are hot-reloaded by the IntegrityChecker.</div>
          </div>
        </div>
      </div>
    </div>
  </header>

  <main>
    <div class="wrap">
      <div id="live"    class="list"  role="tabpanel" aria-labelledby="tab-live"></div>

      <div id="tree"    class="tree"  role="tabpanel" aria-labelledby="tab-tree" style="display:none">
        <div class="treebar">
        <input id="treeSearch" class="input" placeholder="Search PIDs, names, verdict/class..." data-tip="Filter nodes by PID, name, verdict/class" />
        <button class="btn" id="treeRefresh"  data-tip="Refresh tree data">Refresh</button>
        <button class="btn" id="treeExpand"   data-tip="Expand all nodes">Expand all</button>
        <button class="btn" id="treeCollapse" data-tip="Collapse all nodes">Collapse all</button>
        <button class="btn" id="treeCopy"     data-tip="Copy the visible tree to clipboard">Copy</button>
        <button class="btn" id="treeExport"   data-tip="Download the process tree as JSON">Export JSON</button>
        </div>
        <div id="treeRoot"></div>
      </div>

      <div id="about"   class="panel" role="tabpanel" aria-labelledby="tab-about" style="display:none"></div>
    </div>
  </main>

    <!-- Integrity diff modal -->
  <div id="modal" role="dialog" aria-modal="true"
     aria-labelledby="modalTitle" aria-describedby="modalBody"
     style="display:none; position:fixed; inset:0; background:rgba(0,0,0,.45); z-index:9998;">
    <div id="modalCard" class="card" style="position:absolute; left:50%; top:50%; transform:translate(-50%,-50%); width:min(920px, 96vw); max-height:86vh; overflow:auto;">
      <div style="display:flex; align-items:center; justify-content:space-between; gap:10px; margin-bottom:8px;">
        <div class="mono" id="modalTitle"><b>File changes</b></div>
        <button class="btn" id="modalClose" aria-label="Close dialog">Close</button>
      </div>
      <div id="modalBody" class="small mono"></div>
    </div>
  </div>

  <script>
    const state = { tab:"live", levels:{info:true,warning:true,critical:true}, paused:false, q:"", timer:null, forceCollapsed:false,treeQ:"" };
    // sync initial from buttons (prevents drift)
    document.querySelectorAll('#bar-live .chip[data-level]').forEach(btn => {
      const lvl = btn.getAttribute('data-level');
      const on  = btn.getAttribute('data-on') === 'true';
      state.levels[lvl] = on;
    });
    // reflect pressed state for screen readers
    document.querySelectorAll('#bar-live .chip[data-level]').forEach(btn => {
      const on = btn.getAttribute('data-on') === 'true';
      btn.setAttribute('aria-pressed', on ? 'true' : 'false');
    });

    const listEl = document.getElementById('live'), searchEl = document.getElementById('search');
    const countEl = document.getElementById('count'), totalEl = document.getElementById('total');
    const pauseBtn = document.getElementById('pause'), pauseText = document.getElementById('pauseText');
    // on init
    const savedPaused = localStorage.getItem('custoseye.paused');
    if (savedPaused !== null) state.paused = savedPaused === 'true';
    pauseBtn.setAttribute('data-on', state.paused ? 'true' : 'false');
    pauseText.textContent = state.paused ? 'Paused' : 'Live';

    const treeEl = document.getElementById('treeRoot'), aboutEl = document.getElementById('about');

    // ----- Preserve <details> open state -----
    const openKeys = new Set();

    function captureOpenKeys() {
    openKeys.clear();
    document.querySelectorAll('#treeRoot details[data-k]').forEach(d => {
        if (d.open) openKeys.add(d.dataset.k);
    });
    }

    function restoreOpenKeys() {
    document.querySelectorAll('#treeRoot details[data-k]').forEach(d => {
        if (openKeys.has(d.dataset.k)) d.setAttribute('open', '');
    });
    }

    document.getElementById('treeRoot').addEventListener('toggle', (e) => {
    const d = e.target;
    if (d.tagName !== 'DETAILS') return;
    const k = d.dataset.k;
    if (!k) return;
    if (d.open) openKeys.add(k); else openKeys.delete(k);
    });

    //integrity refs
    const iBar = document.getElementById('bar-integrity');
    const iPath = document.getElementById('i-path');
    const iRule = document.getElementById('i-rule');
    const iNote = document.getElementById('i-note');
    const iBrowse = document.getElementById('i-browse');
    const iHash = document.getElementById('i-hash');
    const iAdd = document.getElementById('i-add');
    const iHint = document.getElementById('i-hint');
    const iPreview = document.getElementById('i-preview');
    const iTbody = document.getElementById('i-tbody');

    //tabs
    document.querySelectorAll('.tab').forEach(t => {
    t.addEventListener('click', () => {
        document.querySelectorAll('.tab').forEach(x => x.classList.remove('on'));
        t.classList.add('on'); 
        state.tab = t.getAttribute('data-tab');
        localStorage.setItem('custoseye.tab', state.tab);

        document.getElementById('live').style.display = (state.tab==='live')?'':'none';
        document.getElementById('bar-live').style.display = (state.tab==='live')?'':'none';
        document.getElementById('tree').style.display = (state.tab==='tree')?'':'none';
        iBar.style.display = (state.tab==='integrity')?'':'none';
        aboutEl.style.display = (state.tab==='about')?'':'none';

        if (state.tab === 'integrity') loadTargets();

        // render from caches; background poller keeps data fresh
        renderActive();
    });
    });

    function setupTabsA11y(){
      const tabs = [...document.querySelectorAll('.tab')];
      const tablist = document.querySelector('.tabs');
      tablist.setAttribute('role','tablist');

      function syncAttrs(){
        tabs.forEach(tab=>{
          const on = tab.classList.contains('on');
          tab.setAttribute('role','tab');
          tab.setAttribute('tabindex', on ? '0' : '-1');
          tab.setAttribute('aria-selected', on ? 'true' : 'false');
        });
      }
      syncAttrs();

      tablist.addEventListener('click', syncAttrs);
      tablist.addEventListener('keydown', e=>{
        const i = tabs.findIndex(t=>t.classList.contains('on'));
        if (e.key === 'ArrowRight' || e.key === 'ArrowLeft') {
          e.preventDefault();
          const dir = e.key === 'ArrowRight' ? 1 : -1;
          const next = (i + dir + tabs.length) % tabs.length;
          tabs[next].click();
          tabs[next].focus();
          syncAttrs();
        }
      });
    }
    setupTabsA11y();

    // Restore last tab selection
    const savedTab = localStorage.getItem('custoseye.tab');
    if (savedTab) document.querySelector(`.tab[data-tab="${savedTab}"]`)?.click();

    //live filters
    document.querySelectorAll('#bar-live .chip[data-level]').forEach(btn => {
      btn.addEventListener('click', () => {
        const lvl = btn.getAttribute('data-level');
        const on = btn.getAttribute('data-on') !== 'true';
        btn.setAttribute('data-on', on ? 'true' : 'false');
        btn.setAttribute('aria-pressed', on ? 'true' : 'false'); // NEW
        state.levels[lvl] = on;
        render(window.__data || []);
      });
    });

    pauseBtn.addEventListener('click', () => {
      state.paused = !state.paused;
      localStorage.setItem('custoseye.paused', String(state.paused));
      pauseBtn.setAttribute('data-on', state.paused ? 'true' : 'false');
      pauseText.textContent = state.paused ? 'Paused' : 'Live';
    });

    function debounce(fn, ms){ let h; return (...a)=>{ clearTimeout(h); h=setTimeout(()=>fn(...a), ms); }; }
    searchEl.addEventListener('input', debounce(e => {
      state.q = e.target.value.toLowerCase().trim();
      render(window.__data || []);
    }, 120));
    document.getElementById('refresh').addEventListener('click', fetchData);

    //export live
    document.getElementById('export').addEventListener('click', () => {
      const fmt = document.getElementById('exportFmt')?.value || 'csv';
      const includeInfo = '1';
      const lvls = Object.entries(state.levels).filter(([_,v]) => v).map(([k])=>k).join(',');
      const url = `/api/export?format=${encodeURIComponent(fmt)}&include_info=${includeInfo}` +
                  `&levels=${encodeURIComponent(lvls)}&q=${encodeURIComponent(state.q)}`;
      window.location.href = url;
    });

    function safe(v){ return esc(v ?? ''); }   // reused escape from about tab

    //live list rendering
    function row(ev) {
      const lvl   = (ev.level || 'info').toLowerCase();
      const reason= esc(ev.reason || 'event');
      const src   = esc(ev.source || '');
      const pid   = esc(String(ev.pid || ''));
      const name  = esc(ev.name || '');
      const path  = esc(ev.path || '');
      const cmd   = esc(ev.cmdline || '');
      const ts    = ev.ts ? new Date(ev.ts * 1000).toLocaleTimeString() : '';

      const seen = Number(ev.seen || 1);
      const seenBadge = seen > 1 ? ` <span class="badge" title="Repeated">${'×'}${seen}</span>` : '';

      const trust = ev.csc_verdict
        ? ` | csc=${esc(ev.csc_verdict)}(${esc(ev.csc_class||'unknown')}; ${Number(ev.csc_confidence||0).toFixed(2)})`
        : '';

      const nameOrPath = name || path || cmd || '(unknown)';
      const ident = (ev.source === 'integrity')
        ? `path=${nameOrPath}`
        : `pid=${pid} name=${nameOrPath}`;

      return `
        <div class="row">
          <div class="nowrap"><span class="lvl ${lvl}" title="${lvl === 'critical' ? 'Critical' : lvl === 'warning' ? 'Warning' : 'Info'}">${lvl.toUpperCase()}</span>${seenBadge}</div>
          <div class="mono muted nowrap">${ts}</div>
          <div class="mono nowrap">${reason} | source=${src} ${ident}${trust}</div>
        </div>`;
    }

    function render(data) {
    const byLevel = data.filter(ev => state.levels[(ev.level || 'info').toLowerCase()]);
    const q = state.q;
    const byQuery = q ? byLevel.filter(ev => {
        const s = (ev.reason||'')+' '+(ev.source||'')+' '+(ev.name||'')+' '+(ev.pid||'')+' '+(ev.path||'')+' '+(ev.cmdline||'');
        return s.toLowerCase().includes(q);
    }) : byLevel;

    const prevCount = countEl.textContent;
    const prevTotal = totalEl.textContent;

    countEl.textContent = byQuery.length;
    totalEl.textContent = data.length;
    listEl.innerHTML = byQuery.map(row).join('');

    if (countEl.textContent !== prevCount || totalEl.textContent !== prevTotal) {
      const status = document.getElementById('countStatus');
      if (status) status.textContent = `Showing ${countEl.textContent} of ${totalEl.textContent}`;
    }
    }

    async function fetchData() {
      try {
        const includeInfo = '1';
        const res = await fetch('/api/events?include_info=' + includeInfo);
        const data = await res.json();
        window.__data = data;
        if (!state.paused && state.tab==='live') render(data);
      } catch (e) { /* ignore */ }
    }

      // ---------- Tooltip Manager ----------
  (function () {
    const TOOLTIP_ATTR = 'data-tip';
    let tipEl = null;
    let hideTimer = null;

    function createTip() {
      tipEl = document.createElement('div');
      tipEl.className = 'tooltip';
      tipEl.setAttribute('role', 'tooltip');
      document.body.appendChild(tipEl);
    }

    function showTip(target) {
      if (!tipEl) createTip();
      const text = target.getAttribute(TOOLTIP_ATTR);
      if (!text) return;

      tipEl.textContent = text;
      tipEl.dataset.show = 'true';

      // Position near the element, below or above based on viewport
      const r = target.getBoundingClientRect();
      const gap = 8;
      const ttW = Math.min(280, Math.max(120, tipEl.offsetWidth || 200));
      let x = r.left + (r.width/2) - (ttW/2);
      x = Math.max(8, Math.min(x, window.innerWidth - ttW - 8));

      // First set width, so height is known for Y position
      tipEl.style.width = ttW + 'px';
      tipEl.style.left = x + 'px';

      // After layout, place vertically
      requestAnimationFrame(() => {
        const ttH = tipEl.offsetHeight || 34;
        const above = (r.bottom + gap + ttH > window.innerHeight) && (r.top - gap - ttH > 0);
        const y = above ? (r.top - ttH - gap) : (r.bottom + gap);
        tipEl.style.top = y + 'px';
      });

      // a11y: connect describedby on focus
      if (target.matches(':focus-visible') || document.activeElement === target) {
        if (!tipEl.id) tipEl.id = 'tip-' + Math.random().toString(36).slice(2,8);
        target.setAttribute('aria-describedby', tipEl.id);
      }
    }

    function hideTip(target) {
      if (!tipEl) return;
      tipEl.dataset.show = 'false';
      if (target) target.removeAttribute('aria-describedby');
    }

    function clearHideTimer() {
      if (hideTimer) { clearTimeout(hideTimer); hideTimer = null; }
    }

    // Delegated events for elements with data-tip
    document.addEventListener('pointerenter', (e) => {
      const t = e.target.closest('['+TOOLTIP_ATTR+']');
      if (!t) return;
      clearHideTimer();
      showTip(t);
    }, true);

    document.addEventListener('pointerleave', (e) => {
      const t = e.target.closest('['+TOOLTIP_ATTR+']');
      if (!t) return;
      // small delay to prevent flicker if moving across small gaps
      hideTimer = setTimeout(() => hideTip(t), 50);
    }, true);

    document.addEventListener('focusin', (e) => {
      const t = e.target.closest('['+TOOLTIP_ATTR+']');
      if (!t) return;
      showTip(t);
    });

    document.addEventListener('focusout', (e) => {
      const t = e.target.closest('['+TOOLTIP_ATTR+']');
      if (!t) return;
      hideTip(t);
    });

    // Hide on click so hover vs click don't get mixed up
    document.addEventListener('pointerdown', (e) => {
      const t = e.target.closest('['+TOOLTIP_ATTR+']');
      if (t) hideTip(t);
    });
    // Reposition on scroll/resize
    window.addEventListener('scroll', () => {
      if (tipEl && tipEl.dataset.show === 'true') tipEl.dataset.show = 'false';
    }, true);
    window.addEventListener('resize', () => {
      if (tipEl && tipEl.dataset.show === 'true') tipEl.dataset.show = 'false';
    });
  })();

    // ---------- Integrity diff modal + renderer ----------
    const modal = document.getElementById('modal');
    const modalCard = document.getElementById('modalCard');
    const modalTitle = document.getElementById('modalTitle');
    const modalBody = document.getElementById('modalBody');
    const modalClose = document.getElementById('modalClose');

    let lastFocused = null;

    function esc(s){ return String(s).replace(/[&<>"']/g, m=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;' }[m])); }

    function showModal(title, html) {
      lastFocused = document.activeElement;
      modalTitle.innerHTML = `<b>${esc(title||'')}</b>`;
      modalBody.innerHTML = html; // html built from escaped parts as you do
      modal.style.display = '';
      modalCard.setAttribute('tabindex','-1');
      modalCard.focus();
    }

    function hideModal() {
      modal.style.display = 'none';
      modalTitle.textContent = '';
      modalBody.textContent = '';
      modalCard.removeAttribute('tabindex');
      lastFocused?.focus();
    }

    document.addEventListener('keydown', (e) => {
      if (modal.style.display !== 'none' && e.key === 'Escape') hideModal();
    });

    modalClose.addEventListener('click', hideModal);
    modal.addEventListener('click', (e) => { if (e.target === modal) hideModal(); });

    modal.addEventListener('keydown', (e) => {
    if (e.key !== 'Tab') return;
    const focusables = modal.querySelectorAll('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])');
    const list = Array.from(focusables).filter(el => !el.hasAttribute('disabled'));
    if (!list.length) return;
    const first = list[0], last = list[list.length - 1];
    if (e.shiftKey && document.activeElement === first) { e.preventDefault(); last.focus(); }
    else if (!e.shiftKey && document.activeElement === last) { e.preventDefault(); first.focus(); }
  });

    function bytesHuman(n) {
      if (!Number.isFinite(n) || n < 0) return String(n);
      const units = ['B','KiB','MiB','GiB','TiB'];
      let i = 0, v = n;
      while (v >= 1024 && i < units.length - 1) { v /= 1024; i++; }
      return `${v.toFixed(v < 10 && i ? 2 : 0)} ${units[i]}`;
    }

    function renderDiff(payload) {
      if (!payload || payload.ok !== true) {
        const err = payload && payload.error ? payload.error : 'No diff available';
        return `<div class="small">Error: ${err}</div>`;
      }
      const s = payload.summary || {};
      const regions = payload.regions || [];

      const zipChanges = payload.zip_changes || [];
      let zipHTML = '';
      if (zipChanges.length) {
        const rows = zipChanges.map(z => {
          const ch = (z.change || '').toString();
          const member = esc(z.member || '');
          if (ch === 'modified') {
            return `<tr>
              <td class="mono mono-wrap">${member}</td>
              <td>${esc(ch)}</td>
              <td class="mono">${esc(String(z.size_before ?? ''))}</td>
              <td class="mono">${esc(String(z.size_after ?? ''))}</td>
            </tr>`;
          }
          return `<tr>
            <td class="mono mono-wrap">${member}</td>
            <td>${esc(ch)}</td>
            <td class="mono">${esc(String(z.size ?? ''))}</td>
            <td class="mono">—</td>
          </tr>`;
        }).join('');
        zipHTML = `
          <div class="card" style="margin:8px 0">
            <div class="mono"><b>ZIP members changed</b> <span class="small muted">(e.g., DOCX internals)</span></div>
            <table class="tbl" style="margin-top:6px">
              <thead><tr><th>Member</th><th>Change</th><th>Size (before)</th><th>Size (after)</th></tr></thead>
              <tbody>${rows}</tbody>
            </table>
          </div>`;
      }

      const head = `
        <div class="mono" style="margin-bottom:8px">
          <div><b>${esc(s.file || '')}</b></div>
          <div>Changed chunks: ${s.changed_chunks} · Regions shown: ${s.regions_returned}</div>
          <div>Approx changed: ${bytesHuman(s.approx_changed_bytes)} (${(s.approx_percent_of_file||0)}% of file)</div>
          <div>Chunk size: ${bytesHuman(s.chunk_size)} · Baseline size: ${bytesHuman(s.baseline_size)} → Current size: ${bytesHuman(s.current_size)}</div>
        </div>
      `;

      if (!regions.length) {
        return head + `<div class="small">No differing regions found.</div>`;
      }

      const st = payload.summary_text || {};
      const summaryHTML = (st.headline || st.details) ? `
        <div class="card" style="margin:8px 0">
          <div class="mono"><b>${esc(st.headline || '')}</b></div>
          ${st.details ? `<div class="small" style="margin-top:4px">${esc(st.details)}</div>` : ``}
        </div>
      ` : '';

      const rows = regions.map((r, i) => {
        const oldList = (r.old_chunk_hashes || []).map(h => `<code>${esc(h)}</code>`).join(', ');
        const newList = (r.new_chunk_hashes || []).map(h => `<code>${esc(h)}</code>`).join(', ');
        const pv = r.preview || {};
        // split hex preview into spaced bytes for readability
        const spacedHex = (pv.hex || '').replace(/(..)/g, '$1 ').trim();
        const ascii = pv.ascii || '';

        return `
          <div class="card" style="margin-bottom:8px">
            <div class="mono"><b>Region ${i+1}</b> — offset ${r.start_offset} .. ${r.end_offset} (${bytesHuman(r.length)})</div>
            <div class="small">Chunks ${r.chunk_idx_start}..${r.chunk_idx_end}</div>
            <div class="small" style="margin-top:6px"><b>Old chunk hashes</b>: ${oldList || '(none)'}</div>
            <div class="small"><b>New chunk hashes</b>: ${newList || '(none)'}</div>
            <div class="small" style="margin-top:6px"><b>Preview (after)</b> · ${pv.bytes||0} bytes shown</div>
            <pre class="mono" style="white-space:pre-wrap; overflow-wrap:anywhere; border:1px solid var(--border); border-radius:8px; padding:8px; background:var(--rowAlt);">${spacedHex}</pre>
            <div class="small muted">ASCII: <span class="mono" style="word-break:break-all">${ascii}</span></div>
          </div>
        `;
      }).join('');

      return head + summaryHTML + zipHTML + rows;
    }

  // ---------- Background caches ----------
  let __events = [];
  let __tree = [];
  let __targets = [];
  let __about = null;

  // Render only the active tab using caches
  function renderActive() {
    if (state.tab === 'live') {
      render(__events || []);
      return;
    }
    if (state.tab === 'tree') {
    const filtered = filterTreeList(__tree || [], state.treeQ);
    captureOpenKeys(); // remember what is open
    treeEl.innerHTML = (filtered || []).map(n => renderNode(n, 0)).join('');
    restoreOpenKeys(); // re-open after render
    return;
    }
    if (state.tab === 'integrity') {
      renderTargets(__targets || []);
      return;
    }
    if (state.tab === 'about') {
      const a = __about;
      if (!a) return;
      aboutEl.innerHTML = `
        <div class="mono"><b>CustosEye</b></div>
        <div class="muted">Local-only dashboard for monitoring.</div>
        <div class="mono" style="margin-top:6px">Version: ${a.version || 'dev'}</div>
        <div class="mono">Build: ${a.build || '-'}</div>
        <div class="mono">Buffer size: ${a.buffer_max}</div>
      `;
    }
 }

    // ---------------- process tree ----------------
    const treeSearch = document.getElementById('treeSearch');
    const dTree = debounce((e) => {
      state.treeQ = e.target.value.toLowerCase().trim();
      state.forceCollapsed = false;
      renderActive();
    }, 120);
    treeSearch.addEventListener('input', dTree);
    document.getElementById('treeRefresh').addEventListener('click', fetchTree);
    // Expand all handler: also clear the latch
    document.getElementById('treeExpand').addEventListener('click', () => {
    state.forceCollapsed = false;
    document.querySelectorAll('#treeRoot details[data-k]').forEach(d => {
        d.setAttribute('open','');
        openKeys.add(d.dataset.k);
    });
    });
    // Collapse all handler
    document.getElementById('treeCollapse').addEventListener('click', () => {
    document.querySelectorAll('#treeRoot details[data-k]').forEach(d => d.removeAttribute('open'));
    openKeys.clear();
    state.forceCollapsed = true;   // <— latch
    renderActive();                // force re-render with everything closed
    // clear the latch after render so future expands work normally
    queueMicrotask(() => { state.forceCollapsed = false; });
    });
    document.getElementById('treeCopy').addEventListener('click', copyTree);
    document.getElementById('treeExport').addEventListener('click', () => {
    window.location.href = `/api/proctree?as=json`;
    });

    async function fetchTree() {
    try {
        const res = await fetch('/api/proctree');
        const data = await res.json();
        const filtered = filterTreeList(data, state.treeQ);
        captureOpenKeys();
        treeEl.innerHTML = filtered.map(n => renderNode(n, 0)).join('');
        restoreOpenKeys();
    } catch (e) {}
    }

    function filterTreeList(list, q) {
      if (!q) return list;
      function match(n) {
        const s = `${n.pid} ${n.name} ${n.csc_verdict||''} ${n.csc_class||''}`.toLowerCase();
        return s.includes(q);
      }
      function filterNode(n) {
        const kids = (n.children||[]).map(filterNode).filter(Boolean);
        if (match(n) || kids.length) return { ...n, children: kids };
        return null;
      }
      return list.map(filterNode).filter(Boolean);
    }

    function pill(verdict, cls, conf) {
      const v = (verdict||'unknown').toLowerCase();
      // map v2 verdicts to existing pill styles:
      // malicious/suspicious → low, caution → medium, trusted → high, unknown → medium
      const style = (v === 'trusted') ? 'high'
                  : (v === 'malicious' || v === 'suspicious') ? 'low'
                  : 'medium';
      const cc = typeof conf === 'number' ? conf.toFixed(2) : '';
      const text = [v, cls||'', cc ? `(${cc})` : ''].filter(Boolean).join(' · ');
      return `<span class="pill ${style}">${text}</span>`;
    }

    function renderNode(n, depth, parentKey = '') {
      const key = parentKey ? `${parentKey}>${n.pid}` : String(n.pid);
      const isOpen = state.forceCollapsed
        ? false
        : (state.treeQ ? true : openKeys.has(key));   // auto-open when searching
      const head = `<span class="caret"></span><span class="mono">PID ${n.pid}</span> <span class="mono">${n.name}</span> ${pill(n.csc_verdict, n.csc_class, n.csc_confidence)}`;
      const kidsHTML = (n.children || []).map(c => renderNode(c, depth + 1, key)).join('');
      if (!kidsHTML) {
        return `<div style="margin-left:10px"><span class="mono">PID ${n.pid}</span> <span class="mono">${n.name}</span> ${pill(n.csc_verdict, n.csc_class, n.csc_confidence)}</div>`;
      }
      // IMPORTANT: data-k holds the stable key; we set open if in cache
      return `<details data-k="${key}"${isOpen ? ' open' : ''}><summary aria-label="Toggle children">${head}</summary>${kidsHTML}</details>`;
    }

    function toggleAll(open) {
      document.querySelectorAll('#treeRoot details').forEach(d => {
        if (open) d.setAttribute('open','');
        else d.removeAttribute('open');
      });
    }

    async function copyTree() {
      const text = document.getElementById('treeRoot').innerText.trim();
      try {
        if (navigator.clipboard && navigator.clipboard.writeText) {
          await navigator.clipboard.writeText(text);
        } else {
          const tmp = document.createElement('textarea');
          tmp.value = text;
          document.body.appendChild(tmp);
          tmp.select();
          document.execCommand('copy');
          document.body.removeChild(tmp);
        }
        alert('Tree copied to clipboard');
      } catch {
        alert('Failed to copy');
      }
    }

    // ---------------- about ----------------
    function shortHash(h) {
    if (!h) return '';
    if (/^[0-9a-fA-F]{40,}$/.test(h)) return h.slice(0, 8) + '…' + h.slice(-6);
    return h; // keep mtime+size as-is
    }

    function splitStatus(s) {
    if (!s) return { main: '', note: '' };
    const m = s.match(/^([^()]+)\s*\((.+)\)\s*$/); // "OK (baseline set)"
    if (m) return { main: m[1].trim(), note: m[2].trim() };
    return { main: s.trim(), note: '' };
    }

    // ---------------- integrity tab logic ----------------
    async function loadTargets() {
    try {
        const res = await fetch('/api/integrity/targets');
        const data = await res.json();
        renderTargets(data);
    } catch (e) {
        iTbody.innerHTML = `<tr><td colspan="5" class="small">Failed to load targets</td></tr>`;
    }
    }

    function renderTargets(list) {
      if (!Array.isArray(list) || list.length === 0) {
        iTbody.innerHTML = `<tr><td colspan="5" class="small">No files being watched yet.</td></tr>`;
        return;
      }

      iTbody.innerHTML = list.map(row => {
        const note = (row.note || '').trim();
        const pathCell = `
          <td class="baseline-cell">
            <div class="baseline">
              <span class="mono mono-wrap">${row.path || ''}</span>
              ${note ? `<span class="small muted">Note: ${note}</span>` : ''}
            </div>
          </td>`;
        const ruleCell = `<td>${row.rule || 'sha256'}</td>`;

        const baselineRaw = row.rule === 'sha256'
          ? (row.sha256 || '')
          : ((row.mtime && row.size) ? `mtime=${row.mtime} size=${row.size}` : '(none)');
        const baselineCell = `
          <td class="baseline-cell">
            <div class="baseline">
              <span class="mono mono-wrap">${baselineRaw}</span>
            </div>
          </td>`;

        const status = row.last_result || '';
        const { main: statusMain, note: statusNote } = splitStatus(status);
        const badgeCls = statusMain.toUpperCase().startsWith('OK') ? 'ok' : (status ? 'bad' : '');
        const statusHTML = status
          ? `<div class="status">
              <span class="badge ${badgeCls}">${statusMain}</span>
              ${statusNote ? `<span class="small muted">${statusNote}</span>` : ''}
            </div>`
          : '';
        const statusCell = `<td>${statusHTML}</td>`;

        const showView = (statusMain || '').toUpperCase().startsWith('CHANGED');
        const hasBaselineBlob = !!(row.baseline_blob && !row.baseline_blob.error);

        const actionsCell = `
          <td>
            <div class="row-actions">
              ${showView ? `<button class="btn" data-act="viewdiff" data-path="${encodeURIComponent(row.path || '')}">View changes</button>` : ''}
              ${hasBaselineBlob ? `<button class="btn" data-act="downloadBaseline" data-path="${encodeURIComponent(row.path || '')}">Download baseline</button>` : ''}
              <button class="btn" data-act="rehash" data-path="${encodeURIComponent(row.path || '')}">Re-hash</button>
              <button class="btn" data-act="remove" data-path="${encodeURIComponent(row.path || '')}">Remove</button>
            </div>
          </td>`;

        return `<tr>${pathCell}${ruleCell}${baselineCell}${statusCell}${actionsCell}</tr>`;
      }).join('');

      iTbody.querySelectorAll('button[data-act="downloadBaseline"]').forEach(btn => {
        btn.addEventListener('click', () => {
          const path = decodeURIComponent(btn.getAttribute('data-path'));
          window.location.href = `/api/integrity/baseline/download?path=${encodeURIComponent(path)}`;
        });
      });

      // Wire actions (after rendering)
      iTbody.querySelectorAll('button[data-act="viewdiff"]').forEach(btn => {
        btn.addEventListener('click', async () => {
          const path = decodeURIComponent(btn.getAttribute('data-path'));
          try {
            const r = await fetch('/api/integrity/diff', {
              method: 'POST',
              headers: {'Content-Type': 'application/json'},
              body: JSON.stringify({ path, max_regions: 50 })
            });
            const j = await r.json();
            showModal('File changes', renderDiff(j));
          } catch {
            showModal('File changes', `<div class="small">Failed to compute diff</div>`);
          }
        });
      });

      iTbody.querySelectorAll('button[data-act="rehash"]').forEach(btn => {
        btn.addEventListener('click', async () => {
          const path = decodeURIComponent(btn.getAttribute('data-path'));
          const r = await fetch('/api/integrity/hash', {
            method:'POST',
            headers:{'Content-Type':'application/json'},
            body: JSON.stringify({ path })
          });
          const j = await r.json();
          alert((j.sha256 ? `SHA-256:\n${j.sha256}` : 'No hash') + (j.error ? `\n\nError: ${j.error}` : ''));
          loadTargets();
        });
      });

      iTbody.querySelectorAll('button[data-act="remove"]').forEach(btn => {
        btn.addEventListener('click', async () => {
          const path = decodeURIComponent(btn.getAttribute('data-path'));
          if (!confirm('Remove from watch list?')) return;
          await fetch('/api/integrity/targets', {
            method:'DELETE',
            headers:{'Content-Type':'application/json'},
            body: JSON.stringify({ path })
          });
          loadTargets();
        });
      });
    }

    iBrowse.addEventListener('click', async () => {
      iHint.textContent = 'Opening Windows file dialog...';
      try {
        const r = await fetch('/api/integrity/browse', { method:'POST' });
        const j = await r.json();
        if (j.path) { iPath.value = j.path; iHint.textContent = ''; } else { iHint.textContent = 'No file selected'; }
      } catch(e) { iHint.textContent = 'Browse not available'; }
    });

    function withBusy(btn, fn){
    const wasDisabled = btn.disabled;
    btn.disabled = true;
    btn.setAttribute('aria-busy','true');
    return Promise.resolve()
      .then(fn)
      .finally(()=>{
        btn.disabled = wasDisabled;
        btn.removeAttribute('aria-busy');
      });
  }

    iHash.addEventListener('click', () => withBusy(iHash, async () => {
      const path = iPath.value.trim();
      if (!path) { iHint.textContent = 'Pick a file first'; return; }
      iHint.textContent = 'Hashing...';
      const r = await fetch('/api/integrity/hash', {
        method:'POST',
        headers:{'Content-Type':'application/json'},
        body: JSON.stringify({path})
      });
      const j = await r.json();
      if (j.sha256) {
        iPreview.textContent = `SHA-256: ${j.sha256}  |  size=${j.size}  |  mtime=${j.mtime}`;
        iHint.textContent = 'Preview ready';
      } else {
        iPreview.textContent = '';
        iHint.textContent = j.error || 'Failed to hash';
      }
    }));

    iAdd.addEventListener('click', () => withBusy(iAdd, async () => {
      const path = iPath.value.trim();
      if (!path) { iHint.textContent = 'Pick a file first'; return; }
      const rule = iRule.value;
      const note = iNote.value.trim();
      iHint.textContent = 'Saving...';
      const r = await fetch('/api/integrity/targets', {
        method:'POST',
        headers:{'Content-Type':'application/json'},
        body: JSON.stringify({path, rule, note})
      });
      const j = await r.json();
      if (j.ok) {
        iHint.textContent = 'Saved';
        iPreview.textContent = '';
        iNote.value = '';
        iPath.value = '';                 // clear so placeholder shows again
        iPath.dispatchEvent(new Event('input'));
        iPath.blur();
        loadTargets();
      } else {
        iHint.textContent = j.error || 'Failed to save';
      }
    }));

    // Background poller: keep ALL tabs live; render only the active one
    let inFlight = false;
    let lastTreeAt = 0;
    let pollCtrl = null;

    async function tick() {
      if (state.paused || inFlight) return;
      inFlight = true;

      if (pollCtrl && pollCtrl.abort) pollCtrl.abort();
      const AC = window.AbortController;
      pollCtrl = AC ? new AC() : null;

      try {
        const wantsTree = state.tab === 'tree';
        const now = Date.now();
        const needTree = wantsTree || (now - lastTreeAt > 8000); // every 8s if not on tab
        const includeInfo = '1';

        const jobs = [
          fetch(`/api/events?include_info=${includeInfo}`, { signal: pollCtrl?.signal }), // 0
          fetch(`/api/integrity/targets`,                 { signal: pollCtrl?.signal }),   // 1
          fetch(`/api/about`,                             { signal: pollCtrl?.signal }),   // 2
          fetch(`/api/ping`,                              { signal: pollCtrl?.signal }).catch(() => ({ ok: true })) // 3
        ];
        if (needTree) {
          jobs.push(
            fetch(`/api/proctree`, { signal: pollCtrl?.signal }).then(r => {
              lastTreeAt = now;
              return r;
            }) // 4
          );
        }

        const results = await Promise.allSettled(jobs);

        const evR    = results[0];
        const targR  = results[1];
        const aboutR = results[2];
        const treeR  = needTree ? results[4] : null;

        if (evR?.status === 'fulfilled')   __events  = await evR.value.json();
        if (targR?.status === 'fulfilled') __targets = await targR.value.json();
        if (aboutR?.status === 'fulfilled') __about  = await aboutR.value.json();

        if (needTree && treeR && treeR.status === 'fulfilled') {
          __tree = await treeR.value.json();
          if (openKeys.size === 0 && Array.isArray(__tree)) {
            for (const root of __tree) openKeys.add(String(root.pid));
          }
          if (state.tab === 'tree') {
            renderActive();
            inFlight = false;
            return;
          }
        }

        renderActive();
      } catch (_e) {
        // ignore transient errors
      } finally {
        inFlight = false;
      }
    }

    // pause when tab not visible
    document.addEventListener('visibilitychange', () => {
      if (document.hidden) {
        state.paused = true;
      } else {
        const savedPaused = localStorage.getItem('custoseye.paused');
        state.paused = savedPaused === 'true';
      }
      pauseBtn?.setAttribute('data-on', state.paused ? 'true' : 'false');
      if (pauseText) pauseText.textContent = state.paused ? 'Paused' : 'Live';
    });

    // avoid duplicate timers if this script runs twice
    if (state.timer) clearInterval(state.timer);

    // start the poller
    state.timer = setInterval(tick, 2500);

    // clean up the timer when leaving the page
    window.addEventListener('beforeunload', () => { if (state.timer) clearInterval(state.timer); });

    // initial render
    tick();
  </script>
</body>
</html>