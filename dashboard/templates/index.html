<!--
  goal: CustosEye dashboard, a single-page web application for viewing live security events, process tree, and file integrity monitoring.
  contains all HTML, CSS, and JavaScript inline. polls the backend API for events and renders them in real-time.
  supports tabs for Live Events, Process Tree, Integrity monitoring, and About page.
-->
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>CustosEye · Live</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link rel="icon" href="/static/assets/favicon.ico?v=2">
  <link rel="icon" type="image/png" sizes="32x32" href="/static/assets/favicon-32x32.png?v=2">
  <link rel="icon" type="image/png" sizes="16x16" href="/static/assets/favicon-16x16.png?v=2">
  <link rel="apple-touch-icon" href="/static/assets/apple-touch-icon.png?v=2">
  <link rel="preload" href="/static/assets/logo_warning.svg" as="image" type="image/svg+xml">
  <style>
    /* CSS styles: theme variables, layout, and component styling */
    :root {
      --bg:#0b0f14; --panel:#141a22; --text:#e7eef7; --muted:#9ab;
      --chip-info:#2a6df1; --chip-warning:#e6a700; --chip-critical:#d43c3c; --chip-border:rgba(255,255,255,0.2);
      --accent:#7cc5ff; --ok:#1db954; --border:#1f2a36; --row:#10161e; --rowAlt:#0d131a; --input:#0f141b;
      --tab:#0f151d; --tabOn:#1b2634;
      --trust-low:#c03d3d; --trust-medium:#c27b00; --trust-high:#1db954;
      --bad:#c03d3d; --warn:#e6a700; --good:#1db954;
    }
    @media (prefers-color-scheme: light) {
      :root {
        --bg:#f6f8fb; --panel:#fff; --text:#10131a; --muted:#445;
        --chip-info:#2a6df1; --chip-warning:#c27b00; --chip-critical:#b61e1e; --chip-border:rgba(0,0,0,0.15);
        --accent:#1565c0; --ok:#128b3a; --border:#e7ebf0; --row:#fff; --rowAlt:#f8fafc; --input:#f3f6fa;
        --tab:#f1f4f8; --tabOn:#e5ebf3;
      }
    }
    * { box-sizing: border-box; }
    body { margin:0; background:var(--bg); color:var(--text); font:14px/1.45 -apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Arial; }
    header { position:sticky; top:0; z-index:5; backdrop-filter: blur(6px); background:linear-gradient(180deg,rgba(0,0,0,0.2),transparent); border-bottom:1px solid var(--border); }
    .wrap { max-width:1100px; margin:0 auto; padding:16px; }
    .title { display:flex; align-items:center; gap:10px; margin:4px 0 10px; font-weight:700; letter-spacing:.2px; font-size:18px; }
    .subtitle { color:var(--muted); font-size:12px; }
    .panel { background:var(--panel); border:1px solid var(--border); border-radius:12px; padding:12px; box-shadow:0 6px 20px rgba(0,0,0,0.15); }
    .tabs { display:flex; gap:8px; margin-bottom:10px; }
    .tab { background:var(--tab); border:1px solid var(--border); border-radius:8px; padding:6px 10px; cursor:pointer; user-select:none; }
    .tab.on { background:var(--tabOn); border-color:var(--accent); }
    .controls { 
      display:flex; 
      flex-wrap:wrap; 
      gap:12px; 
      align-items:center; 
      padding:14px; 
      background:var(--panel); 
      border:1px solid var(--border); 
      border-radius:12px; 
      box-shadow:0 2px 8px rgba(0,0,0,0.08);
    }
    .chip { 
      display:inline-flex; 
      align-items:center; 
      gap:8px; 
      border:1px solid var(--chip-border); 
      padding:8px 14px; 
      border-radius:999px; 
      font-size:13px; 
      font-weight:500;
      cursor:pointer; 
      user-select:none; 
      background:transparent; 
      color:var(--text);
      transition:all 0.2s ease;
      box-shadow:0 1px 3px rgba(0,0,0,0.1);
    }
    .chip:hover {
      transform:translateY(-1px);
      box-shadow:0 3px 6px rgba(0,0,0,0.15);
    }
    .chip:active {
      transform:translateY(0);
      box-shadow:0 1px 2px rgba(0,0,0,0.1);
    }
    .chip[data-on="true"] { 
      background:rgba(124,197,255,0.15); 
      border-color:var(--accent);
      box-shadow:0 2px 4px rgba(0,0,0,0.12);
    }
    .chip .dot { 
      width:10px; 
      height:10px; 
      border-radius:999px; 
      box-shadow:0 0 0 2px rgba(255,255,255,0.3) inset;
    }
    .chip.info .dot { background:var(--chip-info); }
    .chip.warning .dot { background:var(--chip-warning); }
    .chip.critical .dot { background:var(--chip-critical); }
    .chip.ok .dot { background:var(--ok); }
    .input { 
      background:var(--input); 
      border:1px solid var(--border); 
      padding:10px 14px; 
      border-radius:8px; 
      color:var(--text); 
      min-width:220px;
      font-size:13px;
      transition:all 0.2s ease;
    }
    .input:focus {
      outline:none;
      border-color:var(--accent);
      box-shadow:0 0 0 3px color-mix(in oklab, var(--accent) 15%, transparent);
    }
    .btn { 
      background:var(--accent); 
      color:white; 
      border:0; 
      padding:10px 16px; 
      border-radius:8px; 
      cursor:pointer;
      font-size:13px;
      font-weight:500;
      transition:all 0.2s ease;
      box-shadow:0 2px 4px rgba(0,0,0,0.1);
    }
    .btn:hover {
      transform:translateY(-1px);
      box-shadow:0 4px 8px rgba(0,0,0,0.15);
    }
    .btn:active {
      transform:translateY(0);
      box-shadow:0 1px 2px rgba(0,0,0,0.1);
    }
    .controls-group {
      display:flex;
      gap:10px;
      align-items:center;
      padding-left:12px;
      border-left:1px solid var(--border);
    }
    .controls-group:first-child {
      border-left:none;
      padding-left:0;
    }
    .list { 
      margin-top:16px; 
      background:var(--panel);
      border:1px solid var(--border);
      border-radius:12px;
      padding:8px;
      box-shadow:0 2px 8px rgba(0,0,0,0.08);
      transition:opacity 0.2s ease-in-out; 
    }
    .list.updating { opacity:0.7; }
    .row { 
      display:grid; 
      grid-template-columns:108px 100px 1fr; 
      gap:14px; 
      padding:12px 14px; 
      border-bottom:1px solid var(--border); 
      background:var(--row); 
      align-items:start;
      border-radius:8px;
      margin:4px 0;
      transition:all 0.2s ease;
    }
    .row:last-child {
      border-bottom:none;
    }
    .row:nth-child(odd) { background:var(--rowAlt); }
    .row:hover {
      background:color-mix(in oklab, var(--accent) 5%, var(--row));
      border-color:color-mix(in oklab, var(--accent) 30%, var(--border));
      box-shadow:0 2px 6px rgba(0,0,0,0.1);
      transform:translateX(2px);
    }
    .row:nth-child(odd):hover {
      background:color-mix(in oklab, var(--accent) 5%, var(--rowAlt));
    }
    .row.new-row { animation:fadeInRow 0.2s ease-in; }
    @keyframes fadeInRow {
      from { opacity:0; transform:translateY(-2px); }
      to { opacity:1; transform:translateY(0); }
    }
    .lvl { 
      display:inline-flex; 
      align-items:center; 
      gap:8px; 
      padding:6px 12px; 
      border-radius:999px; 
      font-weight:600; 
      letter-spacing:.3px;
      font-size:11px;
      border:1px solid transparent;
      transition:all 0.2s ease;
      box-shadow:0 1px 3px rgba(0,0,0,0.1);
    }
    .lvl.info {
      color: var(--chip-info);
      background: rgba(42,109,241,.14); /* fallback */
      background: color-mix(in oklab, var(--chip-info) 14%, transparent);
      border-color: color-mix(in oklab, var(--chip-info) 30%, transparent);
    }
    .lvl.warning {
      color: var(--chip-warning);
      background: rgba(230,167,0,.18);  /* fallback */
      background: color-mix(in oklab, var(--chip-warning) 18%, transparent);
      border-color: color-mix(in oklab, var(--chip-warning) 30%, transparent);
    }
    .lvl.critical {
      color: var(--chip-critical);
      background: rgba(212,60,60,.18);  /* fallback */
      background: color-mix(in oklab, var(--chip-critical) 18%, transparent);
      border-color: color-mix(in oklab, var(--chip-critical) 30%, transparent);
    }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; font-size:12px; }
    .muted { color:var(--muted); }
    .count { font-weight:600; }
    .nowrap { white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
    /* event content: allows wrapping with proper line spacing and word breaking for long text */
    .event-content { overflow-wrap: anywhere; word-break: break-word; white-space: normal; line-height: 1.5; }

    /* process tree */
    .tree { margin-top:12px; }
    .treebar { 
      display:flex; 
      gap:10px; 
      align-items:center; 
      margin-bottom:16px; 
      padding:12px; 
      background:var(--panel); 
      border:1px solid var(--border); 
      border-radius:12px; 
      flex-wrap:wrap;
      box-shadow:0 2px 8px rgba(0,0,0,0.08);
    }
    .treebar .input { 
      flex:1; 
      min-width:280px; 
      background:var(--input); 
      border:1px solid var(--border); 
      padding:10px 14px; 
      border-radius:8px; 
      color:var(--text);
      font-size:13px;
      transition:all 0.2s ease;
    }
    .treebar .input:focus {
      outline:none;
      border-color:var(--accent);
      box-shadow:0 0 0 3px color-mix(in oklab, var(--accent) 15%, transparent);
    }
    .treebar .btn { 
      padding:10px 16px; 
      font-size:13px; 
      font-weight:500;
      transition:all 0.2s ease;
      box-shadow:0 2px 4px rgba(0,0,0,0.1);
    }
    .treebar .btn:hover {
      transform:translateY(-1px);
      box-shadow:0 4px 8px rgba(0,0,0,0.15);
    }
    .treebar .btn:active {
      transform:translateY(0);
      box-shadow:0 1px 2px rgba(0,0,0,0.1);
    }
    .treebar-group {
      display:flex;
      gap:8px;
      align-items:center;
      padding-left:12px;
      border-left:1px solid var(--border);
    }
    .treebar-group:first-child {
      border-left:none;
      padding-left:0;
    }
    .pill { 
      display:inline-block; 
      padding:4px 10px; 
      border-radius:999px; 
      border:1px solid var(--border); 
      font-size:11px; 
      font-weight:500;
      letter-spacing:0.3px;
      transition:all 0.2s ease;
    }
    .pill.low { 
      color: var(--trust-low); 
      background:color-mix(in oklab, var(--trust-low) 12%, transparent);
      border-color: color-mix(in oklab, var(--trust-low) 50%, var(--border)); 
    }
    .pill.medium { 
      color: var(--trust-medium); 
      background:color-mix(in oklab, var(--trust-medium) 12%, transparent);
      border-color: color-mix(in oklab, var(--trust-medium) 50%, var(--border)); 
    }
    .pill.high { 
      color: var(--trust-high); 
      background:color-mix(in oklab, var(--trust-high) 12%, transparent);
      border-color: color-mix(in oklab, var(--trust-high) 50%, var(--border)); 
    }
    #treeRoot {
      background:var(--panel);
      border:1px solid var(--border);
      border-radius:12px;
      padding:16px;
      box-shadow:0 2px 8px rgba(0,0,0,0.08);
    }
    .tree-node {
      margin:6px 0;
      padding:10px 12px;
      background:var(--row);
      border:1px solid var(--border);
      border-radius:8px;
      transition:all 0.2s ease;
    }
    .tree-node:hover {
      background:color-mix(in oklab, var(--accent) 5%, var(--row));
      border-color:color-mix(in oklab, var(--accent) 30%, var(--border));
      box-shadow:0 2px 6px rgba(0,0,0,0.1);
    }
    .tree-node-leaf {
      margin:6px 0 6px 20px;
      padding:10px 12px;
      background:var(--rowAlt);
      border:1px solid var(--border);
      border-radius:8px;
      transition:all 0.2s ease;
    }
    .tree-node-leaf:hover {
      background:color-mix(in oklab, var(--accent) 5%, var(--rowAlt));
      border-color:color-mix(in oklab, var(--accent) 30%, var(--border));
    }
    details { 
      margin:6px 0;
    }
    details > summary { 
      list-style: none; 
      cursor: pointer; 
      padding:10px 12px;
      background:var(--row);
      border:1px solid var(--border);
      border-radius:8px;
      transition:all 0.2s ease;
      display:flex;
      align-items:center;
      gap:8px;
    }
    details > summary:hover {
      background:color-mix(in oklab, var(--accent) 5%, var(--row));
      border-color:color-mix(in oklab, var(--accent) 30%, var(--border));
      box-shadow:0 2px 6px rgba(0,0,0,0.1);
    }
    details[open] > summary {
      border-bottom-left-radius:0;
      border-bottom-right-radius:0;
      border-bottom:1px dashed var(--border);
    }
    details > summary > * {
      flex-shrink:0;
    }
    summary::-webkit-details-marker { display:none; }
    .caret { 
      display:inline-flex;
      align-items:center;
      justify-content:center;
      width:20px;
      height:20px;
      border-radius:4px;
      background:color-mix(in oklab, var(--accent) 10%, transparent);
      border:1px solid color-mix(in oklab, var(--accent) 30%, var(--border));
      transition:all 0.2s ease;
      flex-shrink:0;
    }
    .caret::before {
      content:'';
      width:0;
      height:0;
      border-top:5px solid transparent;
      border-bottom:5px solid transparent;
      border-left:6px solid var(--accent);
      transform:translateX(-1px) rotate(-90deg);
      transition:transform 0.2s ease;
    }
    details[open] > summary .caret {
      background:color-mix(in oklab, var(--accent) 20%, transparent);
      border-color:var(--accent);
    }
    details[open] > summary .caret::before {
      transform:translateX(-1px) rotate(0deg);
    }
    details > summary:hover .caret {
      background:color-mix(in oklab, var(--accent) 25%, transparent);
      border-color:var(--accent);
    }
    details > div {
      margin-left:28px;
      margin-top:4px;
      padding-left:12px;
      border-left:2px solid color-mix(in oklab, var(--accent) 20%, var(--border));
    }

    /* integrity tab */
    .grid { display:grid; gap:10px; grid-template-columns: 1fr; }
    .card { background:var(--panel); border:1px solid var(--border); border-radius:12px; padding:12px; }
    .tbl { width:100%; border-collapse: collapse; border-bottom:1px solid var(--border); }
    .tbl tbody tr:last-child td { border-bottom:none; } /* avoid a double line */
    .tbl th, .tbl td { padding:8px; border-bottom:1px solid var(--border); text-align:left; font-size:12px; }
    .badge { 
      display:inline-block; 
      padding:4px 10px; 
      border-radius:999px; 
      border:1px solid var(--border); 
      font-size:11px; 
      font-weight:600;
      background:color-mix(in oklab, var(--accent) 8%, transparent);
      color:var(--accent);
      border-color:color-mix(in oklab, var(--accent) 30%, var(--border));
      margin-left:6px;
      transition:all 0.2s ease;
    }
    .badge.ok { 
      color:var(--good); 
      background:color-mix(in oklab, var(--good) 12%, transparent);
      border-color: color-mix(in oklab, var(--good) 40%, var(--border)); 
    }
    .badge.warn { 
      color:var(--warn); 
      background:color-mix(in oklab, var(--warn) 12%, transparent);
      border-color: color-mix(in oklab, var(--warn) 40%, var(--border)); 
    }
    .badge.bad { 
      color:var(--bad); 
      background:color-mix(in oklab, var(--bad) 12%, transparent);
      border-color: color-mix(in oklab, var(--bad) 40%, var(--border)); 
    }
    .small { font-size:11px; color:var(--muted); }
    .hint { color:var(--muted); font-size:12px; }

    /* Keep the table inside its card */
    .tbl { table-layout: fixed; width: 100%; }

    /* Column sizing (adjust to taste) */
    .tbl th:nth-child(1), .tbl td:nth-child(1) { width: 32%; } /* Path */
    .tbl th:nth-child(2), .tbl td:nth-child(2) { width: 10%; } /* Rule */
    .tbl th:nth-child(3), .tbl td:nth-child(3) { width: 34%; } /* Baseline */
    .tbl th:nth-child(4), .tbl td:nth-child(4) { width: 8%;  } /* Last result */
    .tbl th:nth-child(5), .tbl td:nth-child(5) { width: 16%; } /* Actions */
    .row-actions { display:flex; flex-wrap:wrap; gap:8px; max-width:100%; }
    .row-actions .btn { white-space:nowrap; }
    .tbl th, .tbl td { vertical-align: top; overflow: hidden; text-overflow: ellipsis; }
    /* Allow buttons to wrap without being clipped */
    .tbl td:nth-child(5) { overflow: visible; }
    /* Give Actions a floor so it never collapses too small */
    .tbl td:nth-child(5) { min-width: 110px; position: relative; }

    /* Keep integrity header visible while scrolling */
    .tbl thead th { position: sticky; top: 0; background: var(--panel); z-index: 1; }

    @media (max-width: 760px) {
     .row-actions .btn { padding: 6px 8px; font-size: 11px; }
    }

    /* Slightly tighten button spacing on very small widths */
    @media (max-width: 560px) {
    .row-actions { gap: 6px; }
    }

    /* Let controls in the Integrity table expand beyond the rounded clip */
    .grid .card.allow-overflow { overflow: visible; }

    /* Remove the table's extra bottom rule so nothing sticks out */
    .tbl { border-bottom: 0; }

    /* Put a divider above the integrity hint */
    .tbl + .hint {
    border-top: 1px solid var(--border);
    margin-top: 8px;
    padding-top: 8px;
    }

    /* Baseline cell as a small vertical stack */
    .baseline {
    display: flex;
    flex-direction: column;
    gap: 2px;
    }

    /* Full hash should wrap; allow breaks anywhere for long strings */
    .baseline-cell { overflow: visible; }
    .mono-wrap { overflow-wrap: anywhere; word-break: break-word; white-space: normal; }

    /* Status cell: badge on first line, note on second */
    .status {
    display: flex;
    flex-direction: column;
    gap: 2px;
    align-items: flex-start;
    }

    /* Disabled button styles */
    .btn[aria-busy="true"],
    .btn:disabled {
      opacity: .6;
      cursor: not-allowed;
    }
    
    /* Clear focus styles for keyboard users */
    .tab:focus-visible,
    .btn:focus-visible,
    .input:focus-visible {
      outline: 2px solid var(--accent);
      outline-offset: 2px;
      border-radius: 8px;
    }

    /* --- Tooltips --- */
    .tooltip {
    position: fixed;
    z-index: 9999;
    max-width: 280px;
    padding: 6px 8px;
    border-radius: 8px;
    font-size: 12px;
    line-height: 1.3;
    background: color-mix(in oklab, var(--panel) 80%, #000);
    color: var(--text);
    border: 1px solid var(--border);
    box-shadow: 0 6px 16px rgba(0,0,0,.25);
    pointer-events: none;
    opacity: 0;
    transform: translateY(-2px);
    transition: opacity .12s ease, transform .12s ease;
    }
    .tooltip[data-show="true"] {
    opacity: 1;
    transform: translateY(0);
    }
    @media (prefers-reduced-motion: reduce) {
    .tooltip { transition: none; }
    }

    /* Center the Actions column buttons */
    .tbl td:nth-child(5) {                /* the Actions cell */
      vertical-align: middle;             /* override the global 'top' */
    }

    .tbl td:nth-child(5) .row-actions {   /* the container holding the buttons */
      display: flex;
      flex-direction: column;             /* stack buttons */
      align-items: center;                /* center horizontally */
      justify-content: center;            /* center vertically in the cell */
      gap: 8px;
      margin: 0 auto;                     /* keeps it centered if the cell grows */
    }

    /* Optional: uniform button width for a tidier column */
    .tbl td:nth-child(5) .row-actions .btn {
      width: 140px;                       /* adjust to taste */
      text-align: center;
    }
    
    /* Ensure tooltips appear above the header */
    header { z-index: 20; }
    .tooltip { z-index: 9999; }

    /* On narrow screens, go horizontal so it doesn't get too tall */
    @media (max-width: 760px) {
      .tbl td:nth-child(5) .row-actions {
        flex-direction: row;
        flex-wrap: wrap;
        justify-content: center;
      }
    }

    /* Center the Actions column header */
    .tbl th:nth-child(5) { text-align: center; }

    /* Keep action buttons tidy and wrap-friendly */
    .row-actions .btn {
      max-width: 160px;
      white-space: normal;
    }

    /* --- Diff visualization styles --- */
    .diff-container {
      display: flex;
      gap: 12px;
      margin: 12px 0;
      max-height: 80vh;
      overflow: visible;
    }
    .diff-side {
      flex: 1;
      min-width: 0;
      border: 1px solid var(--border);
      border-radius: 8px;
      overflow: visible;
      background: var(--rowAlt);
      display: flex;
      flex-direction: column;
      max-height: 80vh;
    }
    .diff-header {
      padding: 8px 12px;
      background: var(--panel);
      border-bottom: 1px solid var(--border);
      font-weight: 600;
      font-size: 13px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .diff-lines {
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
      font-size: 12px;
      line-height: 1.5;
      overflow-x: auto;
      overflow-y: auto;
      flex: 1;
      min-height: 0;
    }
    .diff-line {
      display: flex;
      padding: 2px 8px;
    }
    .diff-line-number {
      min-width: 50px;
      padding-right: 12px;
      text-align: right;
      color: var(--muted);
      user-select: none;
      border-right: 1px solid var(--border);
      margin-right: 8px;
    }
    .diff-line-content {
      flex: 1;
      overflow-x: auto;
      white-space: pre-wrap;
      word-wrap: break-word;
    }
    .diff-line.equal {
      background: var(--row);
    }
    .diff-line.added {
      background: var(--row);
      border-left: 3px solid var(--good);
    }
    .diff-line.removed {
      background: var(--row);
      border-left: 3px solid var(--bad);
    }
    .diff-line.modified {
      background: var(--row);
      border-left: 3px solid var(--warn);
    }
    .diff-char-removed {
      background: color-mix(in oklab, var(--bad) 30%, transparent);
      text-decoration: line-through;
      color: var(--bad);
      padding: 1px 2px;
      border-radius: 2px;
    }
    .diff-char-added {
      background: color-mix(in oklab, var(--good) 30%, transparent);
      color: var(--good);
      font-weight: 500;
      padding: 1px 2px;
      border-radius: 2px;
    }
    .diff-char-equal {
      background: transparent;
    }
    .diff-line.hidden {
      display: none;
    }
    .diff-summary {
      padding: 12px;
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 8px;
      margin-bottom: 12px;
    }
    .diff-summary-stats {
      display: flex;
      gap: 16px;
      flex-wrap: wrap;
      margin-top: 8px;
    }
    .diff-stat {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 12px;
    }
    .diff-stat-badge {
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px solid var(--border);
      font-size: 11px;
      font-weight: 600;
    }
    .diff-stat-badge.added { color: var(--good); border-color: color-mix(in oklab, var(--good) 40%, var(--border)); }
    .diff-stat-badge.removed { color: var(--bad); border-color: color-mix(in oklab, var(--bad) 40%, var(--border)); }
    .diff-stat-badge.modified { color: var(--warn); border-color: color-mix(in oklab, var(--warn) 40%, var(--border)); }
    .diff-binary-info {
      padding: 16px;
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 8px;
      margin: 12px 0;
    }
    .diff-binary-info h4 {
      margin: 0 0 8px 0;
      font-size: 14px;
      color: var(--text);
    }
    .diff-binary-info p {
      margin: 8px 0;
      font-size: 12px;
      color: var(--muted);
      line-height: 1.6;
    }
    .diff-color-chip {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      border: 1px solid var(--border);
      border-radius: 999px;
      padding: 1px 6px;
      font-size: 11px;
      line-height: 1.2;
      background: color-mix(in oklab, var(--panel) 70%, transparent);
    }
    .diff-color-chip-dot {
      width: 12px;
      height: 12px;
      border-radius: 999px;
      border: 1px solid rgba(0,0,0,0.2);
      box-shadow: 0 0 0 1px rgba(255,255,255,0.4) inset;
    }
    .diff-color-chip-arrow {
      margin: 0 4px;
      color: var(--muted);
      font-weight: 600;
    }
    .diff-color-flow {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      flex-wrap: wrap;
    }
    .diff-highlight-chip {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      border: 1px solid color-mix(in oklab, var(--border) 70%, transparent);
      border-radius: 999px;
      padding: 1px 8px;
      font-size: 11px;
      line-height: 1.2;
      background: color-mix(in oklab, var(--panel) 70%, transparent);
    }
    .diff-style-chip {
      display: inline-flex;
      align-items: center;
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 1px 8px;
      font-size: 11px;
      line-height: 1.2;
      background: color-mix(in oklab, var(--panel) 70%, transparent);
      color: var(--muted);
    }
    .diff-style-chip.active {
      color: var(--text);
      border-color: color-mix(in oklab, var(--accent) 35%, var(--border));
      background: color-mix(in oklab, var(--accent) 15%, var(--panel));
    }
    .diff-style-chip.bold { font-weight: 600; }
    .diff-style-chip.italic { font-style: italic; }
    .diff-style-chip.underline { text-decoration: underline; }
    .diff-style-chip.strikethrough { text-decoration: line-through; }
    .diff-style-flow {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      flex-wrap: wrap;
    }
    .diff-formatting-sample {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
      margin-bottom: 6px;
    }
    .diff-formatting-text {
      padding: 2px 6px;
      border-radius: 4px;
      background: var(--row);
      min-width: 20px;
      display: inline-flex;
      align-items: center;
    }
    @media (max-width: 768px) {
      .diff-container {
        flex-direction: column;
        max-height: 70vh;
      }
      .diff-side {
        max-height: 70vh;
      }
    }
  </style>
</head>
<body>
  <!-- main HTML structure: header, tabs, and content panels -->
  <header>
    <div class="wrap">
      <div class="title" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:16px;">
        <div style="display:flex; align-items:center; gap:10px;">
          <img src="/favicon.ico" alt="" style="width:35px;height:35px;border-radius:4px;opacity:.9" />
          CustosEye <span class="subtitle">local dashboard</span>
        </div>
        <div style="display:flex; align-items:center; gap:8px;">
          <a href="/auth/enable-2fa" class="btn" style="padding:6px 12px; font-size:12px; text-decoration:none; display:inline-block;" data-tip="Enable or manage 2FA">2FA</a>
          <button id="logoutBtn" class="btn" style="padding:6px 12px; font-size:12px; background:var(--bad);" data-tip="Sign out and shutdown">Logout & Shutdown</button>
        </div>
      </div>

      <!-- tabs -->
      <div class="tabs" role="tablist">
        <div class="tab on" id="tab-live"      data-tab="live"      data-tip="View live events stream" role="tab" aria-selected="true"  tabindex="0">Live Events</div>
        <div class="tab"     id="tab-tree"      data-tab="tree"      data-tip="Inspect the process tree with trust labels"              role="tab" aria-selected="false" tabindex="0">Process Tree</div>
        <div class="tab"     id="tab-integrity" data-tab="integrity" data-tip="Watch files for tamper (hash or mtime+size)"             role="tab" aria-selected="false" tabindex="0">Integrity</div>
        <div class="tab"     id="tab-about"     data-tab="about"     data-tip="Build info and buffer capacity"                          role="tab" aria-selected="false" tabindex="0">About</div>
      </div>

        <!-- Live Events panel: filter controls and event list -->
      <div class="panel" id="bar-live" role="tabpanel" aria-labelledby="tab-live">
        <div class="controls">
          <div class="controls-group">
            <button class="chip info"     data-on="true"  data-level="info"     data-tip="Toggle Info events"><span class="dot"></span>Info</button>
            <button class="chip warning"  data-on="true"  data-level="warning"  data-tip="Toggle Warnings"><span class="dot"></span>Warning</button>
            <button class="chip critical" data-on="true"  data-level="critical" data-tip="Toggle Critical"><span class="dot"></span>Critical</button>
            <button class="chip ok" id="pause" data-on="false" data-tip="Pause or resume background updates"><span class="dot"></span><span id="pauseText">Live</span></button>
          </div>
          <input id="search" class="input" placeholder="Search: reason, source, name, pid..." data-tip="Filter visible rows by text" style="flex:1; min-width:280px;" />
          <div class="controls-group">
            <button class="btn" id="refresh" data-tip="Force an immediate refresh">Refresh</button>
            <select id="exportFmt" class="input" aria-label="Export format" style="min-width:120px; padding:10px 14px;">
              <option value="csv">CSV</option>
              <option value="json">JSON</option>
              <option value="jsonl">JSONL</option>
              <option value="xlsx">XLSX</option>
            </select>
            <button class="btn" id="export"  data-tip="Export current view">Export</button>
          </div>
          <div class="muted" style="font-size:13px; font-weight:500; padding:8px 12px; background:color-mix(in oklab, var(--accent) 8%, transparent); border:1px solid color-mix(in oklab, var(--accent) 25%, var(--border)); border-radius:8px;">Showing <span id="count" class="count" style="color:var(--accent); font-weight:600;">0</span> / <span id="total" class="count" style="color:var(--text); font-weight:600;">0</span></div>
          <span id="countStatus" role="status" style="position:absolute;left:-9999px;top:auto;width:1px;height:1px;overflow:hidden;">
          </span>
        </div>
       </div>

      <!-- integrity panel: file monitoring controls and target list -->
      <div class="panel" id="bar-integrity" role="tabpanel" aria-labelledby="tab-integrity" style="display:none">
        <div class="grid">
          <!-- integrity controls: file picker, path input, rule selection, hash preview -->
          <div class="card">
            <div class="controls" style="gap:8px">
            <button class="btn" id="i-browse" data-tip="Pick a file (File Explorer)">Browse (Windows)</button>
            <input id="i-path" class="input" placeholder="File path (or use Browse)" style="min-width:360px" data-tip="Target file to watch" />
            <select id="i-rule" class="input" style="min-width:160px" data-tip="Choose exact hash or mtime+size rule">
                <option value="sha256">Exact SHA-256</option>
                <option value="mtime+size">mtime + size</option>
            </select>
            <input id="i-note" class="input" placeholder="Note (optional)" style="min-width:200px" data-tip="Optional label for the target" />
            <button class="btn" id="i-hash" data-tip="Compute a preview hash/attributes">Hash Now</button>
            <button class="btn" id="i-add"  data-tip="Save target to the watch list">Save</button>
            <span class="hint" id="i-hint" aria-live="polite"></span>
            </div>
            <div class="small" id="i-preview" aria-live="polite"></div>
          </div>
          <!-- integrity targets table: shows all monitored files with their status -->
          <div class="card allow-overflow">
            <table class="tbl" id="i-table">
              <thead>
                <tr>
                  <th>Path</th>
                  <th>Rule</th>
                  <th>Baseline</th>
                  <th>Last result</th>
                  <th>Actions</th>
                </tr>
              </thead>
              <tbody id="i-tbody"></tbody>
            </table>
            <div class="hint">Targets are stored in <span class="mono">data/integrity_targets.json</span> and are hot-reloaded by the IntegrityChecker.</div>
          </div>
        </div>
      </div>
    </div>
  </header>

  <main>
    <!-- main content area: different panels for each tab -->
    <div class="wrap">
      <!-- live events list: rendered dynamically from API data -->
      <div id="live"    class="list"  role="tabpanel" aria-labelledby="tab-live"></div>

      <!-- process tree: hierarchical view of running processes with trust verdicts -->
      <div id="tree"    class="tree"  role="tabpanel" aria-labelledby="tab-tree" style="display:none">
        <div class="treebar">
          <input id="treeSearch" class="input" placeholder="Search PIDs, names, verdict/class..." data-tip="Filter nodes by PID, name, verdict/class" />
          <div class="treebar-group">
            <button class="btn" id="treeRefresh"  data-tip="Refresh tree data">Refresh</button>
            <button class="btn" id="treeExpand"   data-tip="Expand all nodes">Expand all</button>
            <button class="btn" id="treeCollapse" data-tip="Collapse all nodes">Collapse all</button>
          </div>
          <div class="treebar-group">
            <button class="btn" id="treeCopy"     data-tip="Copy the visible tree to clipboard">Copy</button>
            <button class="btn" id="treeExport"   data-tip="Download the process tree as JSON">Export JSON</button>
          </div>
        </div>
        <div id="treeRoot"></div>
      </div>

      <!-- about panel: version info and system stats (rendered dynamically) -->
      <div id="about"   class="panel" role="tabpanel" aria-labelledby="tab-about" style="display:none"></div>
    </div>
  </main>

    <!-- modal dialog for showing file changes/diffs -->
  <div id="modal" role="dialog" aria-modal="true"
     aria-labelledby="modalTitle" aria-describedby="modalBody"
     style="display:none; position:fixed; inset:0; background:rgba(0,0,0,.45); z-index:9998;">
    <div id="modalCard" class="card" style="position:absolute; left:50%; top:50%; transform:translate(-50%,-50%); width:min(920px, 96vw); max-height:86vh; overflow:auto;">
      <div style="display:flex; align-items:center; justify-content:space-between; gap:10px; margin-bottom:8px;">
        <div class="mono" id="modalTitle"><b>File changes</b></div>
        <button class="btn" id="modalClose" aria-label="Close dialog">Close</button>
      </div>
      <div id="modalBody" class="small mono"></div>
    </div>
  </div>

  <script>
    /* JavaScript: application state, rendering, and API polling */
    
    // application state: current tab, filter settings, search query, etc
    const state = { tab:"live", levels:{info:true,warning:true,critical:true}, paused:false, q:"", timer:null, forceCollapsed:false,treeQ:"" };
    // sync initial from buttons (prevents drift)
    document.querySelectorAll('#bar-live .chip[data-level]').forEach(btn => {
      const lvl = btn.getAttribute('data-level');
      const on  = btn.getAttribute('data-on') === 'true';
      state.levels[lvl] = on;
    });
    // reflect pressed state for screen readers
    document.querySelectorAll('#bar-live .chip[data-level]').forEach(btn => {
      const on = btn.getAttribute('data-on') === 'true';
      btn.setAttribute('aria-pressed', on ? 'true' : 'false');
    });

    const listEl = document.getElementById('live'), searchEl = document.getElementById('search');
    const countEl = document.getElementById('count'), totalEl = document.getElementById('total');
    const pauseBtn = document.getElementById('pause'), pauseText = document.getElementById('pauseText');
    // on init
    const savedPaused = localStorage.getItem('custoseye.paused');
    if (savedPaused !== null) state.paused = savedPaused === 'true';
    pauseBtn.setAttribute('data-on', state.paused ? 'true' : 'false');
    pauseText.textContent = state.paused ? 'Paused' : 'Live';

    const treeEl = document.getElementById('treeRoot'), aboutEl = document.getElementById('about');

    // preserve which process tree nodes are expanded when refreshing
    const openKeys = new Set();

    function captureOpenKeys() {
    openKeys.clear();
    document.querySelectorAll('#treeRoot details[data-k]').forEach(d => {
        if (d.open) openKeys.add(d.dataset.k);
    });
    }

    function restoreOpenKeys() {
    document.querySelectorAll('#treeRoot details[data-k]').forEach(d => {
        if (openKeys.has(d.dataset.k)) d.setAttribute('open', '');
    });
    }

    document.getElementById('treeRoot').addEventListener('toggle', (e) => {
    const d = e.target;
    if (d.tagName !== 'DETAILS') return;
    const k = d.dataset.k;
    if (!k) return;
    if (d.open) openKeys.add(k); else openKeys.delete(k);
    });

    // integrity monitoring UI element references
    const iBar = document.getElementById('bar-integrity');
    const iPath = document.getElementById('i-path');
    const iRule = document.getElementById('i-rule');
    const iNote = document.getElementById('i-note');
    const iBrowse = document.getElementById('i-browse');
    const iHash = document.getElementById('i-hash');
    const iAdd = document.getElementById('i-add');
    const iHint = document.getElementById('i-hint');
    const iPreview = document.getElementById('i-preview');
    const iTbody = document.getElementById('i-tbody');

    // tab switching: show/hide panels and restore saved tab selection
    const tabs = [...document.querySelectorAll('.tab')];
    const tablist = document.querySelector('.tabs');
    
    // function to sync ARIA attributes for accessibility
    function syncTabAttrs(){
      tabs.forEach(tab=>{
        const on = tab.classList.contains('on');
        tab.setAttribute('role','tab');
        // keep all tabs in tab order (tabindex="0") so keyboard users can Tab through them
        tab.setAttribute('tabindex', '0');
        tab.setAttribute('aria-selected', on ? 'true' : 'false');
      });
    }
    
    // tab click handler: switches between tabs
    function switchTab(t) {
        document.querySelectorAll('.tab').forEach(x => x.classList.remove('on'));
        t.classList.add('on'); 
        state.tab = t.getAttribute('data-tab');
        localStorage.setItem('custoseye.tab', state.tab);

        document.getElementById('live').style.display = (state.tab==='live')?'':'none';
        document.getElementById('bar-live').style.display = (state.tab==='live')?'':'none';
        document.getElementById('tree').style.display = (state.tab==='tree')?'':'none';
        iBar.style.display = (state.tab==='integrity')?'':'none';
        aboutEl.style.display = (state.tab==='about')?'':'none';

        if (state.tab === 'integrity') loadTargets();

        // render from caches; background poller keeps data fresh
        renderActive();
        
        // update ARIA attributes after tab switch
        syncTabAttrs();
    }
    
    // set up tab accessibility and keyboard navigation
    function setupTabsA11y(){
      tablist.setAttribute('role','tablist');
      
      // initialize ARIA attributes
      syncTabAttrs();
      
      // handle click events on tabs
      tabs.forEach(t => {
        t.addEventListener('click', () => switchTab(t));
      });
      
      // handle keyboard navigation on individual tabs
      tabs.forEach(tab => {
        tab.addEventListener('keydown', e=>{
          const i = tabs.indexOf(tab);
          if (i === -1) return;
          
          // arrow keys: navigate between tabs and activate the focused tab
          if (e.key === 'ArrowRight' || e.key === 'ArrowLeft') {
            e.preventDefault();
            const dir = e.key === 'ArrowRight' ? 1 : -1;
            const next = (i + dir + tabs.length) % tabs.length;
            switchTab(tabs[next]);
            tabs[next].focus();
          }
          // Enter or Space: activate the currently focused tab
          else if (e.key === 'Enter' || e.key === ' ') {
            e.preventDefault();
            switchTab(tab);
          }
        });
      });
    }
    setupTabsA11y();

    // restore last tab selection from localStorage
    const savedTab = localStorage.getItem('custoseye.tab');
    if (savedTab) document.querySelector(`.tab[data-tab="${savedTab}"]`)?.click();

    // live events filter buttons: toggle info/warning/critical visibility
    document.querySelectorAll('#bar-live .chip[data-level]').forEach(btn => {
      btn.addEventListener('click', () => {
        const lvl = btn.getAttribute('data-level');
        const on = btn.getAttribute('data-on') !== 'true';
        btn.setAttribute('data-on', on ? 'true' : 'false');
        btn.setAttribute('aria-pressed', on ? 'true' : 'false'); // NEW
        state.levels[lvl] = on;
        render(window.__data || []);
        // reset last rendered events when filter changes to force re-render
        __lastRenderedEvents = null;
      });
    });

    // pause/resume button: stops or resumes background polling
    pauseBtn.addEventListener('click', () => {
      state.paused = !state.paused;
      localStorage.setItem('custoseye.paused', String(state.paused));
      pauseBtn.setAttribute('data-on', state.paused ? 'true' : 'false');
      pauseText.textContent = state.paused ? 'Paused' : 'Live';
    });

    // search input: filter events by text search with debouncing
    function debounce(fn, ms){ let h; return (...a)=>{ clearTimeout(h); h=setTimeout(()=>fn(...a), ms); }; }
    searchEl.addEventListener('input', debounce(e => {
      state.q = e.target.value.toLowerCase().trim();
      // reset last rendered events when search changes to force re-render
      __lastRenderedEvents = null;
      render(window.__data || []);
    }, 120));
    document.getElementById('refresh').addEventListener('click', fetchData);

    // export button: download filtered events as CSV or JSON
    document.getElementById('export').addEventListener('click', () => {
      const fmt = document.getElementById('exportFmt')?.value || 'csv';
      const includeInfo = '1';
      const lvls = Object.entries(state.levels).filter(([_,v]) => v).map(([k])=>k).join(',');
      const url = `/api/export?format=${encodeURIComponent(fmt)}&include_info=${includeInfo}` +
                  `&levels=${encodeURIComponent(lvls)}&q=${encodeURIComponent(state.q)}`;
      window.location.href = url;
    });

    function safe(v){ return esc(v ?? ''); }   // reused escape from about tab

    // render a single event row in the live events list
    function row(ev) {
      const lvl   = (ev.level || 'info').toLowerCase();
      const reason= esc(ev.reason || 'event');
      const src   = esc(ev.source || '');
      const pid   = esc(String(ev.pid || ''));
      const name  = esc(ev.name || '');
      const path  = esc(ev.path || '');
      const cmd   = esc(ev.cmdline || '');
      const ts    = ev.ts ? new Date(ev.ts * 1000).toLocaleTimeString() : '';

      const seen = Number(ev.seen || 1);
      const seenBadge = seen > 1 ? ` <span class="badge" title="Repeated">${'×'}${seen}</span>` : '';

      const trust = ev.csc_verdict
        ? ` | csc=${esc(ev.csc_verdict)}(${esc(ev.csc_class||'unknown')}; ${Number(ev.csc_confidence||0).toFixed(2)})`
        : '';

      const nameOrPath = name || path || cmd || '(unknown)';
      const ident = (ev.source === 'integrity')
        ? `path=${nameOrPath}`
        : `pid=${pid} name=${nameOrPath}`;

      // Check if this event was accepted (marked safe) or hash verified
      // Accepted events have the acceptance text appended to the reason with a checkmark
      const isAccepted = ev.accepted === true || (reason.includes('✔ Marked Safe')) || (reason.includes('✔ Hash verified'));
      
      // Parse the reason to separate the original reason from the acceptance text
      let displayReason = reason;
      let acceptanceText = '';
      if (isAccepted) {
        // Check for "Hash verified" first (replaces the reason)
        if (reason.includes('✔ Hash verified')) {
          displayReason = '✔ Hash verified';
          acceptanceText = '';
        } else {
          // Split reason at the acceptance text marker (using em dash separator)
          const parts = reason.split(' — ✔ Marked Safe');
          if (parts.length > 1) {
            displayReason = parts[0]; // Original reason
            acceptanceText = '✔ Marked Safe'; // Acceptance text
          } else {
            // Fallback: just show the reason as-is
            displayReason = reason;
          }
        }
      }

      return `
        <div class="row">
          <div class="nowrap"><span class="lvl ${lvl}" title="${lvl === 'critical' ? 'Critical' : lvl === 'warning' ? 'Warning' : 'Info'}">${lvl.toUpperCase()}</span>${seenBadge}</div>
          <div class="mono muted nowrap">${ts}</div>
          <div class="mono event-content">${displayReason.includes('✔ Hash verified') ? '<span style="color:var(--good);" title="Hash verified">' + displayReason + '</span>' : displayReason}${acceptanceText ? ' — <span style="color:var(--good);" title="Change marked as safe">' + acceptanceText + '</span>' : ''} | source=${src} ${ident}${trust}</div>
        </div>`;
    }

    // simple hash function for quick data comparison
    function hashData(data) {
      if (!Array.isArray(data)) return JSON.stringify(data);
      // for events, create a hash based on key fields that matter
      return data.map(ev => {
        return `${ev.ts || ''}|${ev.level || ''}|${ev.reason || ''}|${ev.source || ''}|${ev.pid || ''}|${ev.name || ''}|${ev.path || ''}|${ev.seen || ''}`;
      }).join('||');
    }
    
    function render(data) {
    const byLevel = data.filter(ev => state.levels[(ev.level || 'info').toLowerCase()]);
    const q = state.q;
    const byQuery = q ? byLevel.filter(ev => {
        // include CSC fields (csc_verdict, csc_class, csc_confidence) in search
        const s = (ev.reason||'')+' '+(ev.source||'')+' '+(ev.name||'')+' '+(ev.pid||'')+' '+(ev.path||'')+' '+(ev.cmdline||'')+' '+(ev.csc_verdict||'')+' '+(ev.csc_class||'')+' '+(ev.csc_confidence||'');
        return s.toLowerCase().includes(q);
    }) : byLevel;

    // check if data has actually changed by comparing hash
    const currentHash = hashData(byQuery);
    const lastHash = __lastRenderedEvents ? hashData(__lastRenderedEvents) : null;
    
    // only update if data has changed
    if (currentHash === lastHash && __lastRenderedEvents) {
      return; // data hasn't changed, skip rendering
    }
    
    // store current filtered data for next comparison
    __lastRenderedEvents = byQuery;

    const prevCount = countEl.textContent;
    const prevTotal = totalEl.textContent;

    // update counts first (these are fast)
    countEl.textContent = byQuery.length;
    totalEl.textContent = data.length;
    
    // update list content only when data changes
    requestAnimationFrame(() => {
      listEl.innerHTML = byQuery.map(row).join('');
    });

    if (countEl.textContent !== prevCount || totalEl.textContent !== prevTotal) {
      const status = document.getElementById('countStatus');
      if (status) status.textContent = `Showing ${countEl.textContent} of ${totalEl.textContent}`;
    }
    }

    // fetch events and other data from the backend API
    async function fetchData() {
      try {
        const includeInfo = '1';
        const res = await fetch('/api/events?include_info=' + includeInfo);
        if (!res.ok) {
          throw new Error(`HTTP ${res.status}: ${res.statusText}`);
        }
        const data = await res.json();
        window.__data = data;
        if (!state.paused && state.tab==='live') render(data);
      } catch (e) {
        // Show error message in Live Events tab if it's active
        if (state.tab === 'live') {
          const liveEl = document.getElementById('live');
          if (liveEl) {
            liveEl.innerHTML = `
              <div style="padding:20px;">
                <div class="panel" style="max-width:600px; margin:0 auto;">
                  <div style="background:var(--bad); color:white; padding:12px; border-radius:8px; margin-bottom:16px;">
                    <div style="font-weight:600; font-size:16px; margin-bottom:8px; display:flex; align-items:center; justify-content:center; gap:8px;">
                      <img src="/static/assets/logo_warning.svg" alt="Warning" style="width:20px; height:20px; object-fit:contain;" />
                      Error Loading Live Events
                    </div>
                    <div style="font-size:14px;">Failed to load events from the server.</div>
                  </div>
                  <div class="small muted" style="text-align:left;">
                    <p><b>Error:</b> ${esc(e.message || 'Unknown error')}</p>
                    <p>This could happen if:</p>
                    <ul style="margin:8px 0; padding-left:20px;">
                      <li>CustosEye was shut down or crashed</li>
                      <li>There was a network error</li>
                      <li>The API endpoint is unavailable</li>
                    </ul>
                    <p style="margin-top:12px;">Try refreshing the page or restarting CustosEye.</p>
                  </div>
                </div>
              </div>
            `;
          }
        }
      }
    }

      // tooltip manager: shows helpful hints when hovering over UI elements
  (function () {
    const TOOLTIP_ATTR = 'data-tip';
    let tipEl = null;
    let hideTimer = null;

    function createTip() {
      tipEl = document.createElement('div');
      tipEl.className = 'tooltip';
      tipEl.setAttribute('role', 'tooltip');
      document.body.appendChild(tipEl);
    }

    function showTip(target) {
      if (!tipEl) createTip();
      const text = target.getAttribute(TOOLTIP_ATTR);
      if (!text) return;

      tipEl.textContent = text;
      tipEl.dataset.show = 'true';

      // Position near the element, below or above based on viewport
      const r = target.getBoundingClientRect();
      const gap = 8;
      const ttW = Math.min(280, Math.max(120, tipEl.offsetWidth || 200));
      let x = r.left + (r.width/2) - (ttW/2);
      x = Math.max(8, Math.min(x, window.innerWidth - ttW - 8));

      // First set width, so height is known for Y position
      tipEl.style.width = ttW + 'px';
      tipEl.style.left = x + 'px';

      // After layout, place vertically
      requestAnimationFrame(() => {
        const ttH = tipEl.offsetHeight || 34;
        const above = (r.bottom + gap + ttH > window.innerHeight) && (r.top - gap - ttH > 0);
        const y = above ? (r.top - ttH - gap) : (r.bottom + gap);
        tipEl.style.top = y + 'px';
      });

      // a11y: connect describedby on focus
      if (target.matches(':focus-visible') || document.activeElement === target) {
        if (!tipEl.id) tipEl.id = 'tip-' + Math.random().toString(36).slice(2,8);
        target.setAttribute('aria-describedby', tipEl.id);
      }
    }

    function hideTip(target) {
      if (!tipEl) return;
      tipEl.dataset.show = 'false';
      if (target) target.removeAttribute('aria-describedby');
    }

    function clearHideTimer() {
      if (hideTimer) { clearTimeout(hideTimer); hideTimer = null; }
    }

    // Delegated events for elements with data-tip
    document.addEventListener('pointerenter', (e) => {
      const t = e.target.closest('['+TOOLTIP_ATTR+']');
      if (!t) return;
      clearHideTimer();
      showTip(t);
    }, true);

    document.addEventListener('pointerleave', (e) => {
      const t = e.target.closest('['+TOOLTIP_ATTR+']');
      if (!t) return;
      // small delay to prevent flicker if moving across small gaps
      hideTimer = setTimeout(() => hideTip(t), 50);
    }, true);

    document.addEventListener('focusin', (e) => {
      const t = e.target.closest('['+TOOLTIP_ATTR+']');
      if (!t) return;
      showTip(t);
    });

    document.addEventListener('focusout', (e) => {
      const t = e.target.closest('['+TOOLTIP_ATTR+']');
      if (!t) return;
      hideTip(t);
    });

    // Hide on click so hover vs click don't get mixed up
    document.addEventListener('pointerdown', (e) => {
      const t = e.target.closest('['+TOOLTIP_ATTR+']');
      if (t) hideTip(t);
    });
    // Reposition on scroll/resize
    window.addEventListener('scroll', () => {
      if (tipEl && tipEl.dataset.show === 'true') tipEl.dataset.show = 'false';
    }, true);
    window.addEventListener('resize', () => {
      if (tipEl && tipEl.dataset.show === 'true') tipEl.dataset.show = 'false';
    });
  })();

    // integrity diff modal: show file changes in a side-by-side view
    const modal = document.getElementById('modal');
    const modalCard = document.getElementById('modalCard');
    const modalTitle = document.getElementById('modalTitle');
    const modalBody = document.getElementById('modalBody');
    const modalClose = document.getElementById('modalClose');

    let lastFocused = null;

    // escape HTML to prevent XSS
    function esc(s){ return String(s).replace(/[&<>"']/g, m=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;' }[m])); }

    // show modal dialog with title and HTML content
    function showModal(title, html) {
      lastFocused = document.activeElement;
      modalTitle.innerHTML = `<b>${esc(title||'')}</b>`;
      modalBody.innerHTML = html; // html built from escaped parts as you do
      modal.style.display = '';
      modalCard.setAttribute('tabindex','-1');
      modalCard.focus();
    }

    function hideModal() {
      // Save scroll positions before closing
      if (window.currentDiffPath && modal.style.display !== 'none') {
        const diffSides = modalBody.querySelectorAll('.diff-side .diff-lines');
        const scrollPositions = [];
        diffSides.forEach(side => {
          scrollPositions.push({
            scrollTop: side.scrollTop,
            scrollLeft: side.scrollLeft
          });
        });
        if (scrollPositions.length > 0) {
          try {
            sessionStorage.setItem(`diff-scroll-${window.currentDiffPath}`, JSON.stringify(scrollPositions));
          } catch (e) {
            // ignore storage errors
          }
        }
      }
      
      modal.style.display = 'none';
      modalTitle.textContent = '';
      modalBody.textContent = '';
      modalCard.removeAttribute('tabindex');
      lastFocused?.focus();
      
      // clear auto-refresh timer when modal closes
      if (window.diffAutoRefreshInterval) {
        clearInterval(window.diffAutoRefreshInterval);
        window.diffAutoRefreshInterval = null;
      }
      window.currentDiffPath = null;
    }

    document.addEventListener('keydown', (e) => {
      if (modal.style.display !== 'none' && e.key === 'Escape') hideModal();
    });

    modalClose.addEventListener('click', hideModal);
    modal.addEventListener('click', (e) => { if (e.target === modal) hideModal(); });

    modal.addEventListener('keydown', (e) => {
    if (e.key !== 'Tab') return;
    const focusables = modal.querySelectorAll('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])');
    const list = Array.from(focusables).filter(el => !el.hasAttribute('disabled'));
    if (!list.length) return;
    const first = list[0], last = list[list.length - 1];
    if (e.shiftKey && document.activeElement === first) { e.preventDefault(); last.focus(); }
    else if (!e.shiftKey && document.activeElement === last) { e.preventDefault(); first.focus(); }
  });

    // format byte count as human-readable string (B, KiB, MiB, etc)
    function bytesHuman(n) {
      if (!Number.isFinite(n) || n < 0) return String(n);
      const units = ['B','KiB','MiB','GiB','TiB'];
      let i = 0, v = n;
      while (v >= 1024 && i < units.length - 1) { v /= 1024; i++; }
      return `${v.toFixed(v < 10 && i ? 2 : 0)} ${units[i]}`;
    }

    // render file diff: side-by-side text comparison or binary change summary
    function renderDiff(payload) {
      if (!payload || payload.ok !== true) {
        const err = payload && payload.error ? payload.error : 'No diff available';
        return `<div class="small">Error: ${err}</div>`;
      }
      const s = payload.summary || {};
      const fileType = payload.file_type || 'binary';
      const textDiff = payload.text_diff;
      const regions = payload.regions || [];

      // Summary header
      const st = payload.summary_text || {};
      const summaryHTML = `
        <div class="diff-summary">
          <div class="mono"><b>${esc(s.file || '')}</b></div>
          ${st.headline ? `<div style="margin-top:6px; font-weight:600">${esc(st.headline)}</div>` : ''}
          ${st.details ? `<div class="small" style="margin-top:4px">${esc(st.details)}</div>` : ''}
          <div class="diff-summary-stats">
            <div class="diff-stat">
              <span class="small muted">Changed:</span>
              <span class="mono">${bytesHuman(s.approx_changed_bytes)} (${(s.approx_percent_of_file||0).toFixed(1)}%)</span>
            </div>
            <div class="diff-stat">
              <span class="small muted">File size:</span>
              <span class="mono">${bytesHuman(s.baseline_size)} → ${bytesHuman(s.current_size)}</span>
            </div>
          </div>
        </div>
      `;

      // Text-based diff (preferred for readable files)
      if (textDiff && textDiff.type === 'text' && textDiff.diff_segments && textDiff.diff_segments.length > 0) {
        const segments = textDiff.diff_segments;
        let addedCount = 0, removedCount = 0;
        
        // Check if this is an Office document (DOCX/PPTX) for smarter counting
        const isOffice = textDiff.is_office || false;
        
        // Helper function to split text into sentences
        const splitIntoSentences = (text) => {
          if (!text) return [];
          // Split by sentence-ending punctuation followed by space or end of string
          // This handles: . ! ? followed by space, newline, or end
          const sentences = text.split(/([.!?]+[\s\n]|[\n])/).filter(s => s.trim().length > 0);
          // Rejoin punctuation with previous sentence
          const result = [];
          for (let i = 0; i < sentences.length; i++) {
            if (sentences[i].match(/^[.!?]+[\s\n]?$/)) {
              if (result.length > 0) {
                result[result.length - 1] += sentences[i];
              }
            } else {
              result.push(sentences[i].trim());
            }
          }
          return result.filter(s => s.length > 0);
        };
        
        // count actual additions and removals from character-level diffs, not just line counts
        segments.forEach(seg => {
          if (seg.type === 'added') {
            if (isOffice) {
              // For Office docs, count by sentences/paragraphs
              const allText = seg.new_lines.join('\n');
              const sentences = splitIntoSentences(allText);
              addedCount += sentences.length > 0 ? sentences.length : 1;
            } else {
              // count added lines
              addedCount += seg.new_lines.length;
            }
          } else if (seg.type === 'removed') {
            if (isOffice) {
              // For Office docs, count by sentences/paragraphs
              const allText = seg.old_lines.join('\n');
              const sentences = splitIntoSentences(allText);
              removedCount += sentences.length > 0 ? sentences.length : 1;
            } else {
              // count removed lines
              removedCount += seg.old_lines.length;
            }
          } else if (seg.type === 'modified') {
            // for modified segments, count actual character/word additions and removals
            const oldCharDiffs = seg.old_char_diffs || [];
            const newCharDiffs = seg.new_char_diffs || [];
            
            if (oldCharDiffs.length > 0 && newCharDiffs.length > 0) {
              if (isOffice) {
                // For Office docs, count distinct contiguous change blocks
                // Each contiguous block of additions/removals counts as 1
                for (let i = 0; i < Math.max(oldCharDiffs.length, newCharDiffs.length); i++) {
                  if (oldCharDiffs[i] && Array.isArray(oldCharDiffs[i])) {
                    // Count contiguous blocks of removals
                    let inRemovalBlock = false;
                    oldCharDiffs[i].forEach(part => {
                      if (part && part.type === 'removed' && part.text && part.text.trim()) {
                        if (!inRemovalBlock) {
                          removedCount++;
                          inRemovalBlock = true;
                        }
                      } else if (part && part.type !== 'removed') {
                        inRemovalBlock = false;
                      }
                    });
                  }
                  
                  if (newCharDiffs[i] && Array.isArray(newCharDiffs[i])) {
                    // Count contiguous blocks of additions
                    let inAdditionBlock = false;
                    newCharDiffs[i].forEach(part => {
                      if (part && part.type === 'added' && part.text && part.text.trim()) {
                        if (!inAdditionBlock) {
                          addedCount++;
                          inAdditionBlock = true;
                        }
                      } else if (part && part.type !== 'added') {
                        inAdditionBlock = false;
                      }
                    });
                  }
                }
              } else {
                // For non-Office files, use word-level counting
                for (let i = 0; i < Math.max(oldCharDiffs.length, newCharDiffs.length); i++) {
                  if (oldCharDiffs[i] && Array.isArray(oldCharDiffs[i])) {
                    oldCharDiffs[i].forEach(part => {
                      if (part && part.type === 'removed' && part.text) {
                        const words = part.text.trim().split(/\s+/).filter(w => w.length > 0);
                        removedCount += words.length > 0 ? words.length : 1;
                      }
                    });
                  }
                  if (newCharDiffs[i] && Array.isArray(newCharDiffs[i])) {
                    newCharDiffs[i].forEach(part => {
                      if (part && part.type === 'added' && part.text) {
                        const words = part.text.trim().split(/\s+/).filter(w => w.length > 0);
                        addedCount += words.length > 0 ? words.length : 1;
                      }
                    });
                  }
                }
              }
            } else {
              // fallback: if no character-level diffs, count as line modifications
              if (isOffice) {
                // For Office docs, count by paragraphs (each line is typically a paragraph)
                const oldLines = seg.old_lines || [];
                const newLines = seg.new_lines || [];
                
                // Count removed paragraphs
                for (let i = 0; i < oldLines.length; i++) {
                  const oldLine = oldLines[i] || '';
                  const newLine = i < newLines.length ? newLines[i] : '';
                  if (oldLine.trim() && !newLine.trim()) {
                    removedCount += 1; // Each removed paragraph counts as 1
                  }
                }
                
                // Count added paragraphs
                for (let i = 0; i < newLines.length; i++) {
                  const newLine = newLines[i] || '';
                  const oldLine = i < oldLines.length ? oldLines[i] : '';
                  if (newLine.trim() && !oldLine.trim()) {
                    addedCount += 1; // Each added paragraph counts as 1
                  }
                }
                
                // Count modified paragraphs (lines that exist in both but differ)
                for (let i = 0; i < Math.min(oldLines.length, newLines.length); i++) {
                  const oldLine = oldLines[i] || '';
                  const newLine = newLines[i] || '';
                  if (oldLine.trim() && newLine.trim() && oldLine !== newLine) {
                    // Modified paragraph - count as 1 removal + 1 addition
                    removedCount += 1;
                    addedCount += 1;
                  }
                }
              } else {
                // For non-Office files, use word-level counting
                const oldLines = seg.old_lines || [];
                const newLines = seg.new_lines || [];
                const maxLines = Math.max(oldLines.length, newLines.length);
                
                for (let i = 0; i < maxLines; i++) {
                  const oldLine = oldLines[i] || '';
                  const newLine = newLines[i] || '';
                  
                  if (oldLine && !newLine) {
                    const words = oldLine.trim().split(/\s+/).filter(w => w.length > 0);
                    removedCount += words.length > 0 ? words.length : 1;
                  } else if (!oldLine && newLine) {
                    const words = newLine.trim().split(/\s+/).filter(w => w.length > 0);
                    addedCount += words.length > 0 ? words.length : 1;
                  } else if (oldLine && newLine && oldLine !== newLine) {
                    const oldWords = oldLine.trim().split(/\s+/).filter(w => w.length > 0);
                    const newWords = newLine.trim().split(/\s+/).filter(w => w.length > 0);
                    const diff = newWords.length - oldWords.length;
                    if (diff > 0) {
                      addedCount += diff;
                    } else if (diff < 0) {
                      removedCount += Math.abs(diff);
                    } else {
                      removedCount += 1;
                      addedCount += 1;
                    }
                  }
                }
              }
            }
          }
        });

        // Build side-by-side diff with proper alignment
        let oldLinesHTML = '';
        let newLinesHTML = '';
        
        segments.forEach(seg => {
          const type = seg.type;
          const oldLines = seg.old_lines || [];
          const newLines = seg.new_lines || [];
          
          if (type === 'equal') {
            // Equal lines - show side by side
            for (let i = 0; i < oldLines.length; i++) {
              const oldLine = oldLines[i];
              const newLine = newLines[i];
              const oldNum = seg.old_start + i;
              const newNum = seg.new_start + i;
              
              oldLinesHTML += `
                <div class="diff-line equal">
                  <span class="diff-line-number">${oldNum}</span>
                  <span class="diff-line-content">${esc(oldLine)}</span>
                </div>
              `;
              
              newLinesHTML += `
                <div class="diff-line equal">
                  <span class="diff-line-number">${newNum}</span>
                  <span class="diff-line-content">${esc(newLine)}</span>
                </div>
              `;
            }
          } else if (type === 'removed') {
            // Removed lines - show on left with red strikethrough, blank on right
            for (let i = 0; i < oldLines.length; i++) {
              const oldLine = oldLines[i];
              const oldNum = seg.old_start + i;
              
              oldLinesHTML += `
                <div class="diff-line removed">
                  <span class="diff-line-number">${oldNum}</span>
                  <span class="diff-line-content"><span class="diff-char-removed">${esc(oldLine)}</span></span>
                </div>
              `;
              
              newLinesHTML += `
                <div class="diff-line equal">
                  <span class="diff-line-number"></span>
                  <span class="diff-line-content"></span>
                </div>
              `;
            }
          } else if (type === 'added') {
            // Added lines - blank on left, show on right with highlighting
            for (let i = 0; i < newLines.length; i++) {
              const newLine = newLines[i];
              const newNum = seg.new_start + i;
              
              // check if we have character-level diffs for added lines (from modified segments that became added)
              const newCharDiffs = seg.new_char_diffs;
              let newContent = '';
              
              if (newCharDiffs && newCharDiffs[i] && Array.isArray(newCharDiffs[i]) && newCharDiffs[i].length > 0) {
                // use character-level diffs if available
                newCharDiffs[i].forEach(part => {
                  if (part && part.text !== undefined && part.text !== null) {
                    const cls = part.type === 'added' ? 'diff-char-added' : 'diff-char-equal';
                    newContent += `<span class="${cls}">${esc(String(part.text))}</span>`;
                  }
                });
              } else {
                // no character-level diffs, highlight entire line as added
                newContent = `<span class="diff-char-added">${esc(newLine)}</span>`;
              }
              
              oldLinesHTML += `
                <div class="diff-line equal">
                  <span class="diff-line-number"></span>
                  <span class="diff-line-content"></span>
                </div>
              `;
              
              newLinesHTML += `
                <div class="diff-line added">
                  <span class="diff-line-number">${newNum}</span>
                  <span class="diff-line-content">${newContent}</span>
                </div>
              `;
            }
          } else if (type === 'modified') {
            // Modified lines - show character-level differences
            const maxLines = Math.max(oldLines.length, newLines.length);
            const oldCharDiffs = seg.old_char_diffs || [];
            const newCharDiffs = seg.new_char_diffs || [];
            
            for (let i = 0; i < maxLines; i++) {
              const oldLine = oldLines[i] || '';
              const newLine = newLines[i] || '';
              const oldNum = i < oldLines.length ? seg.old_start + i : '';
              const newNum = i < newLines.length ? seg.new_start + i : '';
              
              // determine stripe class based on change_type for accurate coloring
              // change_type can be: "addition_only" (green), "removal_only" (red), or "mixed" (warning)
              const changeType = seg.change_type || 'mixed';
              let stripeClass = 'modified'; // default to warning color
              if (changeType === 'addition_only') {
                stripeClass = 'added'; // green stripe for pure additions
              } else if (changeType === 'removal_only') {
                stripeClass = 'removed'; // red stripe for pure removals
              }
              // else: keep 'modified' for mixed changes (warning color)
              
              // Check if we have character-level diffs for this line
              if (oldCharDiffs[i] && newCharDiffs[i] && Array.isArray(oldCharDiffs[i]) && Array.isArray(newCharDiffs[i]) && oldCharDiffs[i].length > 0 && newCharDiffs[i].length > 0) {
                // Render character-level diff
                let oldContent = '';
                let newContent = '';
                
                oldCharDiffs[i].forEach(part => {
                  if (part && part.text !== undefined && part.text !== null) {
                    // render all text, including empty strings (spaces, etc.)
                    const cls = part.type === 'removed' ? 'diff-char-removed' : 'diff-char-equal';
                    oldContent += `<span class="${cls}">${esc(String(part.text))}</span>`;
                  }
                });
                
                newCharDiffs[i].forEach(part => {
                  if (part && part.text !== undefined && part.text !== null) {
                    // render all text, including empty strings (spaces, etc.)
                    const cls = part.type === 'added' ? 'diff-char-added' : 'diff-char-equal';
                    newContent += `<span class="${cls}">${esc(String(part.text))}</span>`;
                  }
                });
                
                // use the stripe class from segment type for accurate coloring
                oldLinesHTML += `
                  <div class="diff-line ${stripeClass}">
                    <span class="diff-line-number">${oldNum}</span>
                    <span class="diff-line-content">${oldContent || esc(oldLine)}</span>
                  </div>
                `;
                
                newLinesHTML += `
                  <div class="diff-line ${stripeClass}">
                    <span class="diff-line-number">${newNum}</span>
                    <span class="diff-line-content">${newContent || esc(newLine)}</span>
                  </div>
                `;
              } else {
                // Fallback: show full line with appropriate stripe type
                oldLinesHTML += `
                  <div class="diff-line ${stripeClass}">
                    <span class="diff-line-number">${oldNum}</span>
                    <span class="diff-line-content">${esc(oldLine)}</span>
                  </div>
                `;
                
                newLinesHTML += `
                  <div class="diff-line ${stripeClass}">
                    <span class="diff-line-number">${newNum}</span>
                    <span class="diff-line-content">${esc(newLine)}</span>
                  </div>
                `;
              }
            }
          }
        });

        // Formatting helpers (JS inside render scope to avoid globals)
        const computeFormattingDelta = (change) => {
          const before = change.before_attrs || {};
          const after = change.after_attrs || {};
          const keys = Array.from(new Set([...Object.keys(before), ...Object.keys(after)]));
          const delta = { added: [], removed: [], changed: [] };
          keys.forEach((key) => {
            const beforeVal = before[key];
            const afterVal = after[key];
            if (beforeVal === undefined && afterVal !== undefined) {
              delta.added.push({ attr: key, value: afterVal });
            } else if (beforeVal !== undefined && afterVal === undefined) {
              delta.removed.push({ attr: key, value: beforeVal });
            } else if (beforeVal !== afterVal) {
              delta.changed.push({ attr: key, before: beforeVal, after: afterVal });
            }
          });
          delta.hasChanges = delta.added.length > 0 || delta.removed.length > 0 || delta.changed.length > 0;
          return delta;
        };

        const formatAttrValue = (attr, value) => {
          if (value === undefined || value === null || value === '') {
            return '';
          }
          if (value === true) {
            return attr;
          }
          return String(value);
        };

        const extractHexColor = (value) => {
          if (!value) return '';
          const match = /#([0-9A-Fa-f]{3,6})/.exec(String(value));
          if (!match) return '';
          let hex = match[1];
          if (hex.length === 3) {
            hex = hex.split('').map((c) => c + c).join('');
          }
          return `#${hex.toUpperCase()}`;
        };

        const renderColorChip = (label) => {
          const normalized = (label || '').trim() || 'color';
          const hex = extractHexColor(label);
          if (!hex) {
            return `<span class="diff-color-chip">${esc(normalized)}</span>`;
          }
          return `
            <span class="diff-color-chip">
              <span class="diff-color-chip-dot" style="background:${hex};"></span>
              <span>${esc(normalized)}</span>
            </span>
          `;
        };

        const describeColorFlow = (before, after) => `
          <span class="diff-color-flow">
            ${renderColorChip(before)}
            <span class="diff-color-chip-arrow">→</span>
            ${renderColorChip(after)}
          </span>
        `;

        const describeColorSingle = (value, prefix) => `
          <span class="diff-color-flow">
            ${prefix ? `<span class="small muted">${esc(prefix)}</span>` : ''}
            ${renderColorChip(value)}
          </span>
        `;

        const getReadableTextColor = (hex) => {
          if (!hex) return '';
          const clean = hex.replace('#', '');
          if (clean.length !== 6) return '';
          const r = parseInt(clean.slice(0, 2), 16) / 255;
          const g = parseInt(clean.slice(2, 4), 16) / 255;
          const b = parseInt(clean.slice(4, 6), 16) / 255;
          const luminance = 0.2126 * r + 0.7152 * g + 0.0722 * b;
          return luminance > 0.6 ? '#000000' : '#FFFFFF';
        };

        const renderHighlightChip = (label) => {
          const normalized = (label || '').trim() || 'highlight';
          const hex = extractHexColor(label);
          if (!hex) {
            return `<span class="diff-highlight-chip">${esc(normalized)}</span>`;
          }
          const textColor = getReadableTextColor(hex) || 'var(--text)';
          return `<span class="diff-highlight-chip" style="background:${hex}; color:${textColor};">${esc(normalized)}</span>`;
        };

        const describeHighlightFlow = (before, after) => `
          <span class="diff-style-flow">
            ${renderHighlightChip(before)}
            <span class="diff-color-chip-arrow">→</span>
            ${renderHighlightChip(after)}
          </span>
        `;

        const describeHighlightSingle = (value, prefix) => `
          <span class="diff-style-flow">
            ${prefix ? `<span class="small muted">${esc(prefix)}</span>` : ''}
            ${renderHighlightChip(value)}
          </span>
        `;

        const STYLE_ATTR_LABELS = {
          bold: 'Bold',
          italic: 'Italic',
          underline: 'Underline',
          strikethrough: 'Strikethrough',
        };

        const isStyleAttr = (attr) =>
          Object.prototype.hasOwnProperty.call(STYLE_ATTR_LABELS, attr);

        const isStyleValueEnabled = (value) => {
          if (value === undefined || value === null) return false;
          if (typeof value === 'boolean') return value;
          const normalized = String(value).trim().toLowerCase();
          return normalized !== '' && normalized !== 'false' && normalized !== 'none' && normalized !== '0';
        };

        const getStyleVariantLabel = (attr, value) => {
          if (value === undefined || value === null) return '';
          const normalized = String(value).trim();
          if (!normalized) return '';
          const lowered = normalized.toLowerCase();
          if (lowered === 'true' || lowered === 'false') {
            return '';
          }
          if ((attr === 'underline' || attr === 'strikethrough') && lowered === 'single') {
            return '';
          }
          return normalized;
        };

        const renderStyleChip = (attr, value) => {
          const label = STYLE_ATTR_LABELS[attr] || attr;
          const enabled = isStyleValueEnabled(value);
          const variant = getStyleVariantLabel(attr, value);
          const classes = ['diff-style-chip', `style-${attr}`];
          if (enabled) {
            classes.push('active');
          }
          return `<span class="${classes.join(' ')}">${esc(label)}${variant ? ` (${esc(variant)})` : ''}</span>`;
        };

        const describeStyleFlow = (attr, before, after) => `
          <span class="diff-style-flow">
            ${renderStyleChip(attr, before)}
            <span class="diff-color-chip-arrow">→</span>
            ${renderStyleChip(attr, after)}
          </span>
        `;

        const describeStyleSingle = (attr, value, prefix) => `
          <span class="diff-style-flow">
            ${prefix ? `<span class="small muted">${esc(prefix)}</span>` : ''}
            ${renderStyleChip(attr, value)}
          </span>
        `;

        const attrsToStyle = (attrs) => {
          if (!attrs) return '';
          const style = [];
          if (attrs.bold) {
            style.push('font-weight:600');
          }
          if (attrs.italic) {
            style.push('font-style:italic');
          }
          if (attrs.underline) {
            const val = String(attrs.underline).toLowerCase();
            style.push(`text-decoration:${val === 'double' ? 'underline double' : 'underline'}`);
          }
          if (attrs.strikethrough) {
            const val = String(attrs.strikethrough).toLowerCase();
            const type = val === 'double' ? 'line-through double' : 'line-through';
            style.push(`text-decoration:${type}`);
          }
          const colorHex = extractHexColor(attrs.color);
          if (colorHex) {
            style.push(`color:${colorHex}`);
          }
          const highlightHex = extractHexColor(attrs.highlight);
          if (highlightHex) {
            style.push(`background:${highlightHex}`);
            if (!attrs.color) {
              const readable = getReadableTextColor(highlightHex);
              if (readable) {
                style.push(`color:${readable}`);
              }
            }
          }
          return style.join('; ');
        };

        const renderStyledText = (text, attrs) => {
          if (!text) return '';
          const styleAttr = attrsToStyle(attrs);
          return `<span class="diff-formatting-text"${styleAttr ? ` style="${styleAttr}"` : ''}>${esc(text)}</span>`;
        };

        let normalizedFormattingChanges = [];
        if (textDiff.formatting_changes && textDiff.formatting_changes.length > 0) {
          const sourceFormattingChanges = textDiff.formatting_changes;

          const resolveFormattingOrders = (changes) => {
            const total = changes.length;
            const orders = new Array(total).fill(null);
            const validIndices = [];

            changes.forEach((change, idx) => {
              const numericOrder =
                typeof change.order === 'number' && Number.isFinite(change.order)
                  ? change.order
                  : null;
              if (numericOrder !== null) {
                orders[idx] = numericOrder;
                validIndices.push(idx);
              }
            });

            let trendScore = 0;
            for (let i = 1; i < validIndices.length; i++) {
              const prevIdx = validIndices[i - 1];
              const currIdx = validIndices[i];
              const prevOrder = orders[prevIdx];
              const currOrder = orders[currIdx];
              const diff = currOrder - prevOrder;
              if (diff > 0) trendScore += 1;
              else if (diff < 0) trendScore -= 1;
            }
            const direction = trendScore <= -2 ? -1 : 1;

            const prevValid = new Array(total).fill(-1);
            let lastValid = -1;
            for (let i = 0; i < total; i++) {
              if (orders[i] !== null) {
                lastValid = i;
              }
              prevValid[i] = lastValid;
            }

            const nextValid = new Array(total).fill(-1);
            let nextValidIdx = -1;
            for (let i = total - 1; i >= 0; i--) {
              if (orders[i] !== null) {
                nextValidIdx = i;
              }
              nextValid[i] = nextValidIdx;
            }

            const STEP = 1;
            for (let i = 0; i < total; i++) {
              if (orders[i] !== null) continue;
              const prevIdx = prevValid[i];
              const nextIdx = nextValid[i];

              if (prevIdx !== -1 && nextIdx !== -1) {
                const prevOrder = orders[prevIdx];
                const nextOrder = orders[nextIdx];
                const gap = nextIdx - prevIdx;
                if (gap > 0 && prevOrder !== nextOrder) {
                  const increment = (nextOrder - prevOrder) / gap;
                  orders[i] = prevOrder + increment * (i - prevIdx);
                } else {
                  orders[i] = prevOrder + direction * STEP * (i - prevIdx);
                }
              } else if (prevIdx !== -1) {
                orders[i] = orders[prevIdx] + direction * STEP * (i - prevIdx);
              } else if (nextIdx !== -1) {
                orders[i] = orders[nextIdx] - direction * STEP * (nextIdx - i);
              } else {
                orders[i] = direction === 1 ? i : -i;
              }
            }

            return orders;
          };

          const resolvedOrders = resolveFormattingOrders(sourceFormattingChanges);

          normalizedFormattingChanges = sourceFormattingChanges
            .map((change, idx) => {
              const delta = computeFormattingDelta(change);
              if (!delta.hasChanges) return null;
              return {
                text: change.text || '',
                delta,
                beforeAttrs: change.before_attrs || {},
                afterAttrs: change.after_attrs || {},
                order: resolvedOrders[idx] ?? 0,
                wordContext: change.word_context || '',
                hasTextChanges: change.has_text_changes || false,
                segments: Array.isArray(change.segments) ? change.segments : null,
              };
            })
            .filter(Boolean)
            .sort((a, b) => (b.order ?? 0) - (a.order ?? 0))
            .reverse();
        }
        const imageChanges = Array.isArray(textDiff.image_changes) ? textDiff.image_changes : [];
        const formattingCount = normalizedFormattingChanges.length;
        const imageChangeCount = imageChanges.length;
        const totalMetaChanges = formattingCount + imageChangeCount;
        
        const statsHTML = `
          <div class="diff-summary-stats" style="margin-top:8px">
            ${addedCount > 0 ? `<div class="diff-stat"><span class="diff-stat-badge added">+${addedCount}</span> <span class="small muted">added</span></div>` : ''}
            ${removedCount > 0 ? `<div class="diff-stat"><span class="diff-stat-badge removed">-${removedCount}</span> <span class="small muted">removed</span></div>` : ''}
            ${totalMetaChanges > 0 ? `<div class="diff-stat"><span class="diff-stat-badge" style="color:var(--warn); border-color:color-mix(in oklab, var(--warn) 40%, var(--border));">+${totalMetaChanges}</span> <span class="small muted">changes</span></div>` : ''}
          </div>
        `;
        
        // Image changes display
        let imageChangesHTML = '';
        if (imageChanges.length > 0) {
          const IMAGE_CHANGES_LIMIT = 5;
          const totalImageChanges = imageChanges.length;
          const hasMoreImages = totalImageChanges > IMAGE_CHANGES_LIMIT;
          const initialImageChanges = hasMoreImages ? imageChanges.slice(0, IMAGE_CHANGES_LIMIT) : imageChanges;
          const remainingImageCount = totalImageChanges - IMAGE_CHANGES_LIMIT;
          
          // Generate unique ID for this diff's image changes panel
          const imagePanelId = 'image-changes-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
          const hiddenImagesId = imagePanelId + '-hidden';
          const toggleImagesButtonId = imagePanelId + '-toggle';
          
          imageChangesHTML = `
            <div style="margin:12px 0; padding:12px; background:var(--panel); border:1px solid var(--border); border-radius:8px;">
              <div style="font-weight:600; margin-bottom:8px; display:flex; align-items:center; gap:6px;"><img src="/static/assets/imagechanges.svg" alt="" style="width:2.0em; height:2.0em; vertical-align:middle;" /> Image Changes ${hasMoreImages ? `(${totalImageChanges} total)` : `(${totalImageChanges})`}</div>
              <div id="${imagePanelId}">
                ${initialImageChanges.map(change => {
                  const img = change.image || {};
                  const changeType = change.change || '';
                  const badgeCls = changeType === 'added' ? 'added' : (changeType === 'removed' ? 'removed' : (changeType === 'resized' ? 'modified' : 'modified'));
                  
                  // Get image name from multiple possible locations
                  const imageName = img.name || change.name || img.path?.split('/').pop() || change.image?.name || 'Unknown';
                  
                  let changeLabel = changeType;
                  let changeDetails = '';
                  
                  if (changeType === 'resized') {
                    const oldW = change.old_width || '?';
                    const oldH = change.old_height || '?';
                    const newW = change.new_width || '?';
                    const newH = change.new_height || '?';
                    changeLabel = 'resized';
                    changeDetails = `<span class="small" style="color:var(--warning); margin-left:8px;">${oldW}×${oldH} → ${newW}×${newH}</span>`;
                  }
                  
                  const altText = img.alt_text || '';
                  const slideNumber = img.slide_number || change.slide_number;
                  
                  // Determine appropriate location message based on file type
                  const fileName = (s.file || '').toLowerCase();
                  const fileTypeStr = textDiff.file_type || '';
                  const isPptx = fileName.endsWith('.pptx') || fileTypeStr === 'PowerPoint';
                  const isDocx = fileName.endsWith('.docx') || fileTypeStr === 'Word document';
                  const isPdf = fileName.endsWith('.pdf') || textDiff.is_pdf || fileTypeStr === 'PDF';
                  
                  let locationLabel = 'Location';
                  let locationValue = '';
                  if (slideNumber) {
                    if (isPptx) {
                      locationLabel = 'slide';
                      locationValue = slideNumber;
                    } else if (isDocx || isPdf) {
                      locationLabel = 'page';
                      locationValue = slideNumber;
                    } else {
                      locationLabel = 'location';
                      locationValue = slideNumber;
                    }
                  } else {
                    if (isPptx) {
                      locationLabel = 'Slide number';
                    } else if (isDocx || isPdf) {
                      locationLabel = 'Page number';
                    } else {
                      locationLabel = 'Location';
                    }
                  }
                  
                  return `
                    <div style="margin:8px 0; padding:8px; background:var(--rowAlt); border-radius:4px;">
                      <div style="display:flex; align-items:center; gap:8px; flex-wrap:wrap;">
                        <span class="diff-stat-badge ${badgeCls}">${changeType === 'added' ? '+' : (changeType === 'removed' ? '-' : '~')}</span>
                        <span style="font-weight:500;">${esc(imageName)}</span>
                        <span class="small muted">(${bytesHuman(img.size || 0)})</span>
                        ${changeDetails}
                        ${img.hash ? `<span class="small mono muted">hash: ${esc(img.hash)}</span>` : ''}
                        ${img.width && img.height ? `<span class="small muted">${img.width}×${img.height}px</span>` : ''}
                      </div>
                      ${slideNumber ? `<div class="small" style="margin-top:4px; color:var(--accent); font-weight:500;">${locationLabel}:${locationValue}</div>` : (!slideNumber ? `<div class="small muted" style="margin-top:4px; display:flex; align-items:center; gap:4px;"><img src="/static/assets/warning.svg" alt="Warning" style="width:22px; height:22px; object-fit:contain;" /> ${locationLabel} not detected - check manually</div>` : '')}
                      ${altText ? `<div class="small muted" style="margin-top:4px; padding-top:4px; border-top:1px solid var(--border);">${esc(altText)}</div>` : ''}
                    </div>
                  `;
                }).join('')}
                ${hasMoreImages ? `
                  <div id="${hiddenImagesId}" style="display:none;">
                    ${imageChanges.slice(IMAGE_CHANGES_LIMIT).map(change => {
                      const img = change.image || {};
                      const changeType = change.change || '';
                      const badgeCls = changeType === 'added' ? 'added' : (changeType === 'removed' ? 'removed' : (changeType === 'resized' ? 'modified' : 'modified'));
                      
                      // Get image name from multiple possible locations
                      const imageName = img.name || change.name || img.path?.split('/').pop() || change.image?.name || 'Unknown';
                      
                      let changeLabel = changeType;
                      let changeDetails = '';
                      
                      if (changeType === 'resized') {
                        const oldW = change.old_width || '?';
                        const oldH = change.old_height || '?';
                        const newW = change.new_width || '?';
                        const newH = change.new_height || '?';
                        changeLabel = 'resized';
                        changeDetails = `<span class="small" style="color:var(--warning); margin-left:8px;">${oldW}×${oldH} → ${newW}×${newH}</span>`;
                      }
                      
                      const altText = img.alt_text || '';
                      const slideNumber = img.slide_number || change.slide_number;
                      
                      // Determine appropriate location message based on file type
                      const fileName = (s.file || '').toLowerCase();
                      const fileTypeStr = textDiff.file_type || '';
                      const isPptx = fileName.endsWith('.pptx') || fileTypeStr === 'PowerPoint';
                      const isDocx = fileName.endsWith('.docx') || fileTypeStr === 'Word document';
                      const isPdf = fileName.endsWith('.pdf') || textDiff.is_pdf || fileTypeStr === 'PDF';
                      
                      let locationLabel = 'Location';
                      let locationValue = '';
                      if (slideNumber) {
                        if (isPptx) {
                          locationLabel = 'slide';
                          locationValue = slideNumber;
                        } else if (isDocx || isPdf) {
                          locationLabel = 'page';
                          locationValue = slideNumber;
                        } else {
                          locationLabel = 'location';
                          locationValue = slideNumber;
                        }
                      } else {
                        if (isPptx) {
                          locationLabel = 'Slide number';
                        } else if (isDocx || isPdf) {
                          locationLabel = 'Page number';
                        } else {
                          locationLabel = 'Location';
                        }
                      }
                      
                      return `
                        <div style="margin:8px 0; padding:8px; background:var(--rowAlt); border-radius:4px;">
                          <div style="display:flex; align-items:center; gap:8px; flex-wrap:wrap;">
                            <span class="diff-stat-badge ${badgeCls}">${changeType === 'added' ? '+' : (changeType === 'removed' ? '-' : '~')}</span>
                            <span style="font-weight:500;">${esc(imageName)}</span>
                            <span class="small muted">(${bytesHuman(img.size || 0)})</span>
                            ${changeDetails}
                            ${img.hash ? `<span class="small mono muted">hash: ${esc(img.hash)}</span>` : ''}
                            ${img.width && img.height ? `<span class="small muted">${img.width}×${img.height}px</span>` : ''}
                          </div>
                          ${slideNumber ? `<div class="small" style="margin-top:4px; color:var(--accent); font-weight:500;">${locationLabel}:${locationValue}</div>` : (!slideNumber ? `<div class="small muted" style="margin-top:4px; display:flex; align-items:center; gap:4px;"><img src="/static/assets/warning.svg" alt="Warning" style="width:22px; height:22px; object-fit:contain;" /> ${locationLabel} not detected - check manually</div>` : '')}
                          ${altText ? `<div class="small muted" style="margin-top:4px; padding-top:4px; border-top:1px solid var(--border);">${esc(altText)}</div>` : ''}
                        </div>
                      `;
                    }).join('')}
                  </div>
                  <div style="margin-top:8px; text-align:center;">
                    <button id="${toggleImagesButtonId}" onclick="
                      (function(e) {
                        if (e) { e.stopPropagation(); e.preventDefault(); }
                        const hidden = document.getElementById('${hiddenImagesId}');
                        const btn = document.getElementById('${toggleImagesButtonId}');
                        const remainingCount = ${remainingImageCount};
                        if (!hidden || !btn) return false;
                        // Check state using data attribute first (more reliable)
                        const isExpanded = btn.getAttribute('data-expanded') === 'true';
                        if (isExpanded) {
                          // Currently expanded, so collapse it
                          hidden.style.display = 'none';
                          btn.textContent = 'Show more (' + remainingCount + ' more)';
                          btn.setAttribute('data-expanded', 'false');
                        } else {
                          // Currently collapsed, so expand it
                          hidden.style.display = 'block';
                          btn.textContent = 'Show less';
                          btn.setAttribute('data-expanded', 'true');
                        }
                        return false;
                      })(event);
                    " style="
                      padding:6px 12px;
                      background:var(--accent);
                      color:var(--bg);
                      border:none;
                      border-radius:4px;
                      cursor:pointer;
                      font-size:13px;
                      font-weight:500;
                    " data-expanded="false">Show more (${remainingImageCount} more)</button>
                  </div>
                ` : ''}
              </div>
            </div>
          `;
        }
        
        // Formatting changes display
        let formattingChangesHTML = '';
        if (normalizedFormattingChanges.length > 0) {
          const FORMATTING_CHANGES_LIMIT = 5;
          const totalChanges = normalizedFormattingChanges.length;
          const hasMore = totalChanges > FORMATTING_CHANGES_LIMIT;
          const initialChanges = hasMore ? normalizedFormattingChanges.slice(0, FORMATTING_CHANGES_LIMIT) : normalizedFormattingChanges;
          const remainingCount = totalChanges - FORMATTING_CHANGES_LIMIT;

          const formattingPanelId = 'formatting-changes-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
          const hiddenChangesId = formattingPanelId + '-hidden';
          const toggleButtonId = formattingPanelId + '-toggle';

            const styledPlusBadge = '<span style="display:inline-block; color:var(--accent); background:color-mix(in oklab, var(--accent) 15%, transparent); border:1px solid color-mix(in oklab, var(--accent) 40%, transparent); border-radius:3px; padding:2px 6px; margin:0 4px; font-weight:700; font-size:0.9em; vertical-align:middle;">+</span>';

            // Heuristic fallback for legacy diffs that don't include explicit segments.
            // ONLY applies when multiple separate, non-adjacent words received different formatting edits
            const formatMergedTextHeuristic = (text) => {
              if (!text) return text;
              const trimmed = text.trim();
              
              // NEVER modify:
              // - Single or two-letter text (partial-word changes)
              if (trimmed.length <= 2) return text;
              
              // - Long text (sentences/paragraphs - these should not be broken up)
              if (trimmed.length > 30) return text;
              
              // - Text with sentence punctuation (full sentences)
              if (trimmed.includes('.') || trimmed.includes('!') || trimmed.includes('?')) return text;
              
              // - Text with multiple spaces (already has word separators)
              if (trimmed.includes('  ') || trimmed.split(/\s+/).length > 3) return text;
              
              // - Text that looks like a continuous region (contains hyphens, etc.)
              if (trimmed.includes('-') || trimmed.includes('—')) return text;
              
              // Only process short text (2-3 words max) that appears to be merged
              // Look for very specific patterns: two common words merged together
              // Examples: "platformand", "andinto" - where two distinct words are clearly merged
              const commonShortWords = ['and', 'the', 'into', 'onto', 'over', 'with', 'from', 'that', 'this', 'for', 'are', 'was', 'has', 'had', 'not', 'but'];
              const commonLongWords = ['platform', 'security', 'endpoint', 'custos', 'custoseye', 'transparent'];
              
              // Check for pattern: longWord + shortWord (e.g., "platformand")
              for (const longWord of commonLongWords) {
                for (const shortWord of commonShortWords) {
                  const pattern = new RegExp(`^(${longWord}${shortWord})(\\b.*)?$`, 'i');
                  const match = trimmed.match(pattern);
                  if (match) {
                    const remaining = match[2] ? match[2].trimStart() : '';
                    return `${longWord} + ${shortWord}${remaining ? ` ${remaining}` : ''}`;
                  }
                }
              }
              
              // Check for pattern: shortWord + shortWord (e.g., "andinto")
              for (let i = 0; i < commonShortWords.length; i++) {
                for (let j = 0; j < commonShortWords.length; j++) {
                  if (i !== j) {
                    const pattern = new RegExp(`^(${commonShortWords[i]}${commonShortWords[j]})(\\b.*)?$`, 'i');
                    const match = trimmed.match(pattern);
                    if (match) {
                      const remaining = match[2] ? match[2].trimStart() : '';
                      return `${commonShortWords[i]} + ${commonShortWords[j]}${remaining ? ` ${remaining}` : ''}`;
                    }
                  }
                }
              }
              
              // If no obvious merged pattern detected, return original text unchanged
              return text;
            };

            const renderFormattingEntry = (entry) => {
              const combinedText = entry.text || '';
              const wordContext = entry.wordContext || '';
              const textLength = combinedText.trim().length;
              const rawSegments = Array.isArray(entry.segments) ? entry.segments : [];
              const cleanedSegments = rawSegments
                .map(part => {
                  if (!part) return '';
                  if (typeof part === 'string') return part.trim();
                  if (typeof part === 'object' && part !== null) {
                    return String(part.text || '').trim();
                  }
                  return '';
                })
                .filter(part => part.length > 0);

              const MAX_SEGMENTS_FOR_DISPLAY = 4;
              const MAX_TEXT_LENGTH_FOR_DISPLAY = 80;
              const hasExplicitSegments = cleanedSegments.length > 1;
              const allowSegmentDisplay =
                hasExplicitSegments &&
                cleanedSegments.length <= MAX_SEGMENTS_FOR_DISPLAY &&
                textLength <= MAX_TEXT_LENGTH_FOR_DISPLAY &&
                cleanedSegments.every(part => part.length <= 30);

              const buildSegmentDisplay = (parts) => {
                if (!parts.length) return '';
                return parts
                  .map((part, index) => {
                    const safe = esc(part);
                    if (index === 0) {
                      return `<span style="white-space:pre-wrap;">${safe}</span>`;
                    }
                    return `${styledPlusBadge}<span style="white-space:pre-wrap;">${safe}</span>`;
                  })
                  .join(' ');
              };

              const buildSegmentSample = (parts, attrs) => {
                if (!parts.length) return '';
                return parts
                  .map((part, index) => {
                    const sample = renderStyledText(part, attrs) || `<span class="diff-formatting-text small muted">(none)</span>`;
                    if (index === 0) return sample;
                    return `${styledPlusBadge}${sample}`;
                  })
                  .join(' ');
              };

              let formattedText = combinedText;
              if (textLength > 2 && !hasExplicitSegments) {
                formattedText = formatMergedTextHeuristic(combinedText);
              }

              let isMerged = false;
              let displayText = '';
              let beforeSample = '';
              let afterSample = '';

              if (allowSegmentDisplay) {
                isMerged = true;
                displayText = buildSegmentDisplay(cleanedSegments);
                beforeSample = buildSegmentSample(cleanedSegments, entry.beforeAttrs);
                afterSample = buildSegmentSample(cleanedSegments, entry.afterAttrs);
              } else if (!hasExplicitSegments && formattedText && formattedText.includes(' + ')) {
                isMerged = true;
                const heuristicParts = formattedText.split(' + ').map(part => part.trim()).filter(Boolean);
                displayText = buildSegmentDisplay(heuristicParts);
                beforeSample = buildSegmentSample(heuristicParts, entry.beforeAttrs);
                afterSample = buildSegmentSample(heuristicParts, entry.afterAttrs);
              } else {
                displayText = formattedText
                  ? `<span style="white-space:pre-wrap;">${esc(formattedText)}</span>`
                  : '<span class="small muted">(blank)</span>';
                beforeSample = renderStyledText(formattedText, entry.beforeAttrs);
                afterSample = renderStyledText(formattedText, entry.afterAttrs);
              }
              
              const mergedNote = isMerged 
                ? `<span class="small" style="display:inline-block; margin-left:8px; padding:2px 6px; color:var(--accent); background:color-mix(in oklab, var(--accent) 15%, transparent); border:1px solid color-mix(in oklab, var(--accent) 40%, transparent); border-radius:3px; font-weight:500; font-style:italic;">(separate characters got changed but are from the same paragraph)</span>`
                : '';
              
              const displayFullText = displayText
                ? `${displayText}${mergedNote && isMerged ? ` ${mergedNote}` : ''}`
                : '<span class="small muted">(blank)</span>';
              
              const normalizedWordContext = wordContext.trim();
              const normalizedCombinedText = combinedText.trim();
              const shouldShowWordContext =
                normalizedWordContext &&
                (!normalizedCombinedText || normalizedWordContext !== normalizedCombinedText);
              const desc = [];

              entry.delta.changed.forEach(change => {
                if (change.attr === 'color') {
                  desc.push(`<div>${describeColorFlow(change.before, change.after)}</div>`);
                } else if (change.attr === 'highlight') {
                  desc.push(`<div>${describeHighlightFlow(change.before, change.after)}</div>`);
                } else if (isStyleAttr(change.attr)) {
                  desc.push(`<div>${describeStyleFlow(change.attr, change.before, change.after)}</div>`);
                } else {
                  const beforeVal = formatAttrValue(change.attr, change.before);
                  const afterVal = formatAttrValue(change.attr, change.after);
                  desc.push(
                    `<div style="color:var(--warn);">${esc(change.attr)}: ${esc(beforeVal)} → ${esc(afterVal)}</div>`
                  );
                }
              });

              entry.delta.removed.forEach(change => {
                if (change.attr === 'color') {
                  desc.push(`<div>${describeColorSingle(change.value, 'removed')}</div>`);
                } else if (change.attr === 'highlight') {
                  desc.push(`<div>${describeHighlightSingle(change.value, 'removed')}</div>`);
                } else if (isStyleAttr(change.attr)) {
                  desc.push(`<div>${describeStyleSingle(change.attr, change.value, 'removed')}</div>`);
                } else {
                  const removedVal = formatAttrValue(change.attr, change.value);
                  desc.push(
                    `<div style="color:var(--bad);">Removed: ${esc(change.attr)}${removedVal ? ` (${esc(removedVal)})` : ''}</div>`
                  );
                }
              });

              entry.delta.added.forEach(change => {
                if (change.attr === 'color') {
                  desc.push(`<div>${describeColorSingle(change.value, 'added')}</div>`);
                } else if (change.attr === 'highlight') {
                  desc.push(`<div>${describeHighlightSingle(change.value, 'added')}</div>`);
                } else if (isStyleAttr(change.attr)) {
                  desc.push(`<div>${describeStyleSingle(change.attr, change.value, 'added')}</div>`);
                } else {
                  const addedVal = formatAttrValue(change.attr, change.value);
                  desc.push(
                    `<div style="color:var(--good);">Added: ${esc(change.attr)}${addedVal ? ` (${esc(addedVal)})` : ''}</div>`
                  );
                }
              });

              if (!beforeSample) {
                beforeSample = renderStyledText(formattedText, entry.beforeAttrs) || '';
              }
              if (!afterSample) {
                afterSample = renderStyledText(formattedText, entry.afterAttrs) || '';
              }
              
              let sampleBlock = '';
              if (beforeSample || afterSample) {
                const beforeDisplay = beforeSample || `<span class="diff-formatting-text small muted">(none)</span>`;
                const afterDisplay = afterSample || `<span class="diff-formatting-text small muted">(none)</span>`;
                sampleBlock = `
                  <div class="diff-formatting-sample">
                    ${beforeDisplay}
                    <span class="diff-color-chip-arrow">→</span>
                    ${afterDisplay}
                  </div>
                `;
              }

              if (desc.length === 0 && !sampleBlock) return '';

              const textChangesNote = entry.hasTextChanges 
                ? `<div style="margin-top:6px; padding:8px; background:color-mix(in oklab, var(--warn) 35%, var(--panel)); color:var(--text); border:1px solid color-mix(in oklab, var(--warn) 75%, var(--border)); border-radius:4px; font-size:0.9em; font-weight:500; box-shadow:0 2px 4px rgba(0,0,0,0.25);">
                    <strong style="color:color-mix(in oklab, var(--warn) 90%, var(--text));">Note:</strong> This sentence also has text additions/removals. See the text changes section below for details.
                   </div>`
                : '';

              return `
                <div style="margin:8px 0; padding:8px; background:var(--rowAlt); border-radius:4px;">
                  <div style="font-weight:500; margin-bottom:4px;">
                    Text:
                    ${displayFullText}
                  </div>
                  ${shouldShowWordContext ? `<div class="small muted">Within word: "${esc(wordContext)}"</div>` : ''}
                  ${sampleBlock}
                  ${desc.length > 0 ? `<div class="small" style="margin-top:4px; display:flex; flex-direction:column; gap:4px;">${desc.join('')}</div>` : ''}
                  ${textChangesNote}
                </div>
              `;
            };

          const renderList = (items) => items.map(renderFormattingEntry).filter(html => html && html !== '').join('');

          formattingChangesHTML = `
            <div style="margin:12px 0; padding:12px; background:var(--panel); border:1px solid var(--border); border-radius:8px;">
              <div style="font-weight:600; margin-bottom:8px; display:flex; align-items:center; gap:6px;"><img src="/static/assets/formattingchanges.svg" alt="" style="width:2.0em; height:2.0em; vertical-align:middle;" /> Formatting Changes (${totalChanges})</div>
              <div id="${formattingPanelId}">
                ${renderList(initialChanges)}
                ${hasMore ? `
                  <div id="${hiddenChangesId}" style="display:none;">
                    ${renderList(normalizedFormattingChanges.slice(FORMATTING_CHANGES_LIMIT))}
                  </div>
                  <div style="margin-top:8px; text-align:center;">
                    <button id="${toggleButtonId}" onclick="
                      (function(e) {
                        if (e) { e.stopPropagation(); e.preventDefault(); }
                        const hidden = document.getElementById('${hiddenChangesId}');
                        const btn = document.getElementById('${toggleButtonId}');
                        const remainingCount = ${remainingCount};
                        if (!hidden || !btn) return false;
                        const isExpanded = btn.getAttribute('data-expanded') === 'true';
                        if (isExpanded) {
                          hidden.style.display = 'none';
                          btn.textContent = 'Show more (' + remainingCount + ' more)';
                          btn.setAttribute('data-expanded', 'false');
                        } else {
                          hidden.style.display = 'block';
                          btn.textContent = 'Show less';
                          btn.setAttribute('data-expanded', 'true');
                        }
                        return false;
                      })(event);
                    " style="
                      padding:6px 12px;
                      background:var(--accent);
                      color:var(--bg);
                      border:none;
                      border-radius:4px;
                      cursor:pointer;
                      font-size:13px;
                      font-weight:500;
                    " data-expanded="false">Show more (${remainingCount} more)</button>
                  </div>
                ` : ''}
              </div>
            </div>
          `;
        }
        

        // Add "Change is OK" button
        const changeIsOKButton = `
          <div style="margin:12px 0; padding:12px; background:var(--panel); border:1px solid var(--border); border-radius:8px;">
            <div style="display:flex; align-items:center; justify-content:space-between; gap:12px;">
              <div>
                <div style="font-weight:600; margin-bottom:4px;">This change is intentional</div>
                <div class="small muted">If you made this change, click here to update the baseline and stop alerts.</div>
              </div>
              <button class="btn" id="acceptBaselineBtn" data-path="${encodeURIComponent(s.file || '')}" style="white-space:nowrap;">
                Mark Change as Intentional
              </button>
            </div>
          </div>
        `;

        return summaryHTML + `
          <div style="margin:12px 0">
            <div class="small muted" style="margin-bottom:8px">
              File type: <b>${esc(textDiff.file_type || 'text file')}</b>
              ${textDiff.is_office ? ' (Office document - extracted text)' : ''}
              ${textDiff.is_pdf ? ' (PDF - extracted text)' : ''}
              ${textDiff.is_config ? ' (Configuration file)' : ''}
              ${textDiff.note ? ` · ${esc(textDiff.note)}` : ''}
            </div>
            ${statsHTML}
            ${imageChangesHTML}
            ${formattingChangesHTML}
            ${changeIsOKButton}
            <div class="diff-container">
              <div class="diff-side">
                <div class="diff-header">
                  <span>Original (Baseline)</span>
                  <span class="small muted">${textDiff.old_line_count || 0} lines</span>
                </div>
                <div class="diff-lines">${oldLinesHTML}</div>
              </div>
              <div class="diff-side">
                <div class="diff-header">
                  <span>Current (Changed)</span>
                  <span class="small muted">${textDiff.new_line_count || 0} lines</span>
                </div>
                <div class="diff-lines">${newLinesHTML}</div>
              </div>
            </div>
          </div>
        `;
      }

      // Binary or Office file diff (fallback)
      if (fileType === 'office') {
        const zipChanges = payload.zip_changes || [];
        if (zipChanges.length) {
          const rows = zipChanges.map(z => {
            const ch = (z.change || '').toString();
            const member = esc(z.member || '');
            if (ch === 'modified') {
              return `<tr>
                <td class="mono mono-wrap">${member}</td>
                <td>${esc(ch)}</td>
                <td class="mono">${bytesHuman(z.size_before ?? 0)}</td>
                <td class="mono">${bytesHuman(z.size_after ?? 0)}</td>
              </tr>`;
            }
            return `<tr>
              <td class="mono mono-wrap">${member}</td>
              <td>${esc(ch)}</td>
              <td class="mono">${bytesHuman(z.size ?? 0)}</td>
              <td class="mono">—</td>
            </tr>`;
          }).join('');
          return summaryHTML + `
            <div class="card" style="margin:8px 0">
              <div class="mono"><b>Office document changes</b> <span class="small muted">(internal components)</span></div>
              <table class="tbl" style="margin-top:6px">
                <thead><tr><th>Component</th><th>Change</th><th>Size (before)</th><th>Size (after)</th></tr></thead>
                <tbody>${rows}</tbody>
              </table>
            </div>
          `;
        }
      }

      // Binary file - show helpful explanation with structured comparison
      if (fileType === 'binary' || (!textDiff && regions.length === 0)) {
        // Add "Change is OK" button for binary files too
        const changeIsOKButton = `
          <div style="margin:12px 0; padding:12px; background:var(--panel); border:1px solid var(--border); border-radius:8px;">
            <div style="display:flex; align-items:center; justify-content:space-between; gap:12px;">
              <div>
                <div style="font-weight:600; margin-bottom:4px;">This change is intentional</div>
                <div class="small muted">If you made this change, click here to update the baseline and stop alerts.</div>
              </div>
              <button class="btn" id="acceptBaselineBtnBinary" data-path="${encodeURIComponent(s.file || '')}" style="white-space:nowrap;">
                Mark Change as Intentional
              </button>
            </div>
          </div>
        `;
        
        let binaryInfo = `
          <div class="diff-binary-info">
            <h4>Binary file changes detected</h4>
            <p>
              This file contains binary data (not readable text). The file has been modified, but we cannot show the exact text changes.
            </p>
            <p>
              <b>What changed:</b> Approximately ${(s.approx_percent_of_file||0).toFixed(1)}% of the file (${bytesHuman(s.approx_changed_bytes || 0)}) has been modified.
            </p>
        `;
        
        // Show structured comparison for binary files if we have region data
        if (regions.length > 0) {
          binaryInfo += `
            <p style="margin-top:12px;"><b>Changed regions:</b> ${regions.length} region(s) detected.</p>
            <div style="margin-top:8px; max-height:200px; overflow:auto;">
          `;
          
          regions.slice(0, 5).forEach((r, i) => {
            const pv = r.preview || {};
            const spacedHex = (pv.hex || '').replace(/(..)/g, '$1 ').trim();
            const ascii = pv.ascii || '';
            binaryInfo += `
              <div style="margin-bottom:8px; padding:8px; background:var(--rowAlt); border-radius:4px; border:1px solid var(--border);">
                <div class="mono small" style="margin-bottom:4px;"><b>Region ${i+1}:</b> bytes ${r.start_offset} to ${r.end_offset} (${bytesHuman(r.length)})</div>
                <pre class="mono" style="white-space:pre-wrap; overflow-wrap:anywhere; font-size:10px; margin:4px 0;">${spacedHex}</pre>
                <div class="small muted">ASCII: <span class="mono" style="word-break:break-all">${esc(ascii)}</span></div>
              </div>
            `;
          });
          
          if (regions.length > 5) {
            binaryInfo += `<div class="small muted">... and ${regions.length - 5} more regions</div>`;
          }
          
          binaryInfo += `</div>`;
        }
        
        binaryInfo += `
            <p style="margin-top:12px;">
              <b>What you can do:</b> Download the original baseline file to compare it with the current version using external tools.
            </p>
          </div>
        `;
        
        return summaryHTML + changeIsOKButton + binaryInfo;
      }

      // Fallback: show chunk-based regions (for binary or when text diff unavailable)
      if (regions.length > 0) {
        const rows = regions.slice(0, 10).map((r, i) => {
          const pv = r.preview || {};
          const spacedHex = (pv.hex || '').replace(/(..)/g, '$1 ').trim();
          const ascii = pv.ascii || '';
          return `
            <div class="card" style="margin-bottom:8px">
              <div class="mono"><b>Changed region ${i+1}</b> — bytes ${r.start_offset} to ${r.end_offset} (${bytesHuman(r.length)})</div>
              <div class="small muted" style="margin-top:6px">Preview of changed content:</div>
              <pre class="mono" style="white-space:pre-wrap; overflow-wrap:anywhere; border:1px solid var(--border); border-radius:8px; padding:8px; background:var(--rowAlt); margin-top:4px; font-size:11px;">${spacedHex}</pre>
              <div class="small muted">ASCII: <span class="mono" style="word-break:break-all">${esc(ascii)}</span></div>
            </div>
          `;
        }).join('');
        return summaryHTML + `
          <div class="card" style="margin:8px 0">
            <div class="mono"><b>Changed regions</b> <span class="small muted">(showing first 10 of ${regions.length})</span></div>
            ${rows}
          </div>
        `;
      }

      return summaryHTML + `<div class="small">No differences found.</div>`;
    }

  // background caches: store API data so all tabs stay fresh even when not visible
  let __events = [];
  let __tree = [];
  let __targets = [];
  let __about = null;
  
  // store last rendered data to detect changes and avoid unnecessary re-renders
  let __lastRenderedEvents = null;
  let __lastRenderedTargets = null;
  let __lastRenderedTree = null;

  // cache data in sessionStorage for instant display when navigating back
  function saveDataCache() {
    try {
      sessionStorage.setItem('custoseye.events', JSON.stringify(__events));
      sessionStorage.setItem('custoseye.tree', JSON.stringify(__tree));
      sessionStorage.setItem('custoseye.targets', JSON.stringify(__targets));
      if (__about) {
        sessionStorage.setItem('custoseye.about', JSON.stringify(__about));
      }
    } catch (e) {
      // ignore storage errors (e.g., private browsing mode)
    }
  }

  // load cached data from sessionStorage for instant display
  function loadDataCache() {
    try {
      const cachedEvents = sessionStorage.getItem('custoseye.events');
      const cachedTree = sessionStorage.getItem('custoseye.tree');
      const cachedTargets = sessionStorage.getItem('custoseye.targets');
      const cachedAbout = sessionStorage.getItem('custoseye.about');
      
      if (cachedEvents) {
        __events = JSON.parse(cachedEvents);
      }
      if (cachedTree) {
        __tree = JSON.parse(cachedTree);
      }
      if (cachedTargets) {
        __targets = JSON.parse(cachedTargets);
      }
      if (cachedAbout) {
        __about = JSON.parse(cachedAbout);
      }
      
      // immediately render cached data if available
      if (__events.length > 0 || __tree.length > 0 || __targets.length > 0) {
        renderActive();
      }
    } catch (e) {
      // ignore storage errors or parsing errors
    }
  }

  // render only the currently active tab using cached data
  function renderActive() {
    if (state.tab === 'live') {
      render(__events || []);
      return;
    }
    if (state.tab === 'tree') {
      const filtered = filterTreeList(__tree || [], state.treeQ);  // apply search filter
      
      // check if tree data has changed
      const currentTreeHash = JSON.stringify(filtered);
      if (currentTreeHash === __lastRenderedTree) {
        return; // tree hasn't changed, skip rendering
      }
      __lastRenderedTree = currentTreeHash;
      
      captureOpenKeys(); // remember which nodes are expanded
      // use requestAnimationFrame for smoother updates
      requestAnimationFrame(() => {
        treeEl.innerHTML = (filtered || []).map(n => renderNode(n, 0)).join('');  // render tree
        restoreOpenKeys(); // restore expanded state after render
      });
      return;
    }
    if (state.tab === 'integrity') {
      renderTargets(__targets || []);  // render integrity targets from cache
      return;
    }
    if (state.tab === 'about') {
      const a = __about;
      if (!a) {
        return; // Just return if no data, don't show error
      }
      aboutEl.innerHTML = `
        <div class="mono"><b>CustosEye</b></div>
        <div class="muted">Local-only dashboard for monitoring.</div>
        <div class="mono" style="margin-top:6px">Version: ${a.version || 'dev'}</div>
        <div class="mono">Build: ${a.build || '-'}</div>
        <div class="mono">Buffer size: ${a.buffer_max}</div>
      `;
    }
 }

    // ---------------- process tree ----------------
    const treeSearch = document.getElementById('treeSearch');
    const dTree = debounce((e) => {
      state.treeQ = e.target.value.toLowerCase().trim();
      state.forceCollapsed = false;
      // reset last rendered tree when search changes to force re-render
      __lastRenderedTree = null;
      renderActive();
    }, 120);
    treeSearch.addEventListener('input', dTree);
    document.getElementById('treeRefresh').addEventListener('click', fetchTree);
    // expand all nodes in the process tree
    document.getElementById('treeExpand').addEventListener('click', () => {
    state.forceCollapsed = false;
    document.querySelectorAll('#treeRoot details[data-k]').forEach(d => {
        d.setAttribute('open','');
        openKeys.add(d.dataset.k);
    });
    });
    // collapse all nodes in the process tree
    document.getElementById('treeCollapse').addEventListener('click', () => {
    document.querySelectorAll('#treeRoot details[data-k]').forEach(d => d.removeAttribute('open'));
    openKeys.clear();
    state.forceCollapsed = true;   // <— latch
    renderActive();                // force re-render with everything closed
    // clear the latch after render so future expands work normally
    queueMicrotask(() => { state.forceCollapsed = false; });
    });
    document.getElementById('treeCopy').addEventListener('click', copyTree);
    document.getElementById('treeExport').addEventListener('click', () => {
    window.location.href = `/api/proctree?as=json`;
    });

    // fetch process tree data from the API and render it
    async function fetchTree() {
    try {
        const res = await fetch('/api/proctree');
        if (!res.ok) {
          throw new Error(`HTTP ${res.status}: ${res.statusText}`);
        }
        const data = await res.json();
        __tree = data; // update cache
        // reset last rendered tree to force re-render after manual refresh
        __lastRenderedTree = null;
        renderActive();
    } catch (e) {
        // Show error message in Process Tree tab if it's active
        if (state.tab === 'tree') {
          const treeRoot = document.getElementById('treeRoot');
          if (treeRoot) {
            treeRoot.innerHTML = `
              <div style="padding:20px;">
                <div class="panel" style="max-width:600px; margin:0 auto;">
                  <div style="background:var(--bad); color:white; padding:12px; border-radius:8px; margin-bottom:16px;">
                    <div style="font-weight:600; font-size:16px; margin-bottom:8px; display:flex; align-items:center; justify-content:center; gap:8px;">
                      <img src="/static/assets/logo_warning.svg" alt="Warning" style="width:20px; height:20px; object-fit:contain;" />
                      Error Loading Process Tree
                    </div>
                    <div style="font-size:14px;">Failed to load process tree from the server.</div>
                  </div>
                  <div class="small muted" style="text-align:left;">
                    <p><b>Error:</b> ${esc(e.message || 'Unknown error')}</p>
                    <p>This could happen if:</p>
                    <ul style="margin:8px 0; padding-left:20px;">
                      <li>CustosEye was shut down or crashed</li>
                      <li>There was a network error</li>
                      <li>The API endpoint is unavailable</li>
                    </ul>
                    <p style="margin-top:12px;">Try clicking "Refresh" or restarting CustosEye.</p>
                  </div>
                </div>
              </div>
            `;
          }
        }
    }
    }

    // filter process tree by search query: matches PID, name, verdict, class, confidence, path, cmdline
    function filterTreeList(list, q) {
      if (!q) return list;
      function match(n) {
        // include all searchable fields: PID, name, CSC verdict/class/confidence, path, cmdline
        const s = `${n.pid} ${n.name || ''} ${n.csc_verdict || ''} ${n.csc_class || ''} ${n.csc_confidence || ''} ${n.path || ''} ${n.cmdline || ''}`.toLowerCase();
        return s.includes(q);
      }
      function filterNode(n) {
        const kids = (n.children||[]).map(filterNode).filter(Boolean);
        if (match(n) || kids.length) return { ...n, children: kids };
        return null;
      }
      return list.map(filterNode).filter(Boolean);
    }

    // create a trust verdict badge pill with color coding
    function pill(verdict, cls, conf) {
      const v = (verdict||'unknown').toLowerCase();
      // map v2 verdicts to existing pill styles:
      // malicious/suspicious → low, caution → medium, trusted → high, unknown → medium
      const style = (v === 'trusted') ? 'high'
                  : (v === 'malicious' || v === 'suspicious') ? 'low'
                  : 'medium';
      const cc = typeof conf === 'number' ? conf.toFixed(2) : '';
      const text = [v, cls||'', cc ? `(${cc})` : ''].filter(Boolean).join(' · ');
      return `<span class="pill ${style}">${text}</span>`;
    }

    // render a single process tree node (recursive for children)
    function renderNode(n, depth, parentKey = '') {
      const key = parentKey ? `${parentKey}>${n.pid}` : String(n.pid);
      const isOpen = state.forceCollapsed
        ? false
        : (state.treeQ ? true : openKeys.has(key));   // auto-open when searching
      const nameDisplay = n.name || '(unnamed)';
      const pathDisplay = n.path ? `<span class="muted" style="font-size:11px; margin-left:8px;">${esc(n.path)}</span>` : '';
      const head = `<span class="caret"></span><span class="mono" style="font-weight:600; color:var(--accent);">PID ${n.pid}</span> <span class="mono" style="font-weight:500;">${esc(nameDisplay)}</span>${pathDisplay} ${pill(n.csc_verdict, n.csc_class, n.csc_confidence)}`;
      const kidsHTML = (n.children || []).map(c => renderNode(c, depth + 1, key)).join('');
      if (!kidsHTML) {
        const leafPathDisplay = n.path ? `<span class="muted" style="font-size:11px; margin-left:8px; display:block; margin-top:4px;">${esc(n.path)}</span>` : '';
        return `<div class="tree-node-leaf"><span class="mono" style="font-weight:600; color:var(--accent);">PID ${n.pid}</span> <span class="mono" style="font-weight:500;">${esc(nameDisplay)}</span>${leafPathDisplay} ${pill(n.csc_verdict, n.csc_class, n.csc_confidence)}</div>`;
      }
      // IMPORTANT: data-k holds the stable key, we set open if in cache
      return `<details data-k="${key}"${isOpen ? ' open' : ''}><summary aria-label="Toggle children">${head}</summary><div>${kidsHTML}</div></details>`;
    }

    function toggleAll(open) {
      document.querySelectorAll('#treeRoot details').forEach(d => {
        if (open) d.setAttribute('open','');
        else d.removeAttribute('open');
      });
    }

    async function copyTree() {
      const text = document.getElementById('treeRoot').innerText.trim();
      try {
        if (navigator.clipboard && navigator.clipboard.writeText) {
          await navigator.clipboard.writeText(text);
        } else {
          const tmp = document.createElement('textarea');
          tmp.value = text;
          document.body.appendChild(tmp);
          tmp.select();
          document.execCommand('copy');
          document.body.removeChild(tmp);
        }
        alert('Tree copied to clipboard');
      } catch {
        alert('Failed to copy');
      }
    }

    // about tab helpers
    // shorten long hashes for display (shows first 8 and last 6 chars)
    function shortHash(h) {
    if (!h) return '';
    if (/^[0-9a-fA-F]{40,}$/.test(h)) return h.slice(0, 8) + '…' + h.slice(-6);
    return h; // keep mtime+size as-is
    }

    // split status string into main status and optional note in parentheses
    function splitStatus(s) {
    if (!s) return { main: '', note: '' };
    const m = s.match(/^([^()]+)\s*\((.+)\)\s*$/); // "OK (baseline set)"
    if (m) return { main: m[1].trim(), note: m[2].trim() };
    return { main: s.trim(), note: '' };
    }

    // integrity tab logic: load and display monitored file targets
    // single-flight request tracking with stale-response guard
    let loadTargetsRequestId = 0;
    let loadTargetsAbortController = null;
    let loadTargetsTimer = null;
    let suppressPollingUntil = 0; // timestamp to suppress polling updates after manual actions
    let optimisticRemoves = new Set(); // track paths that were optimistically removed
    
    // stable hash function: sorted by path, excludes volatile fields
    function stableTargetsHash(list) {
      if (!Array.isArray(list)) return '';
      // sort by path for deterministic ordering
      const sorted = [...list].sort((a, b) => {
        const pathA = (a.path || '').toLowerCase();
        const pathB = (b.path || '').toLowerCase();
        return pathA.localeCompare(pathB);
      });
      // hash only stable fields (path, rule, baseline, status)
      return JSON.stringify(sorted.map(t => ({
        path: t.path || '',
        rule: t.rule || 'sha256',
        sha256: t.sha256 || '',
        mtime: t.mtime || '',
        size: t.size || '',
        last_result: t.last_result || '',
        note: t.note || ''
      })));
    }
    
    async function loadTargets(suppressPolling = false) {
      // cancel any in-flight request
      if (loadTargetsAbortController) {
        loadTargetsAbortController.abort();
      }
      
      // create new request with unique ID
      const requestId = ++loadTargetsRequestId;
      loadTargetsAbortController = new AbortController();
      const signal = loadTargetsAbortController.signal;
      
      // clear debounce timer
      if (loadTargetsTimer) {
        clearTimeout(loadTargetsTimer);
        loadTargetsTimer = null;
      }
      
      // debounce: wait 200ms to batch rapid calls
      loadTargetsTimer = setTimeout(async () => {
        loadTargetsTimer = null;
        try {
          const res = await fetch('/api/integrity/targets', { signal });
          
          // stale-response guard: check BEFORE parsing JSON (saves work if stale)
          if (requestId !== loadTargetsRequestId) {
            return; // stale response, ignore (newer request already in flight)
          }
          
          if (!res.ok) {
            throw new Error(`HTTP ${res.status}: ${res.statusText}`);
          }
          
          const data = await res.json();
          
          // stale-response guard: check AGAIN after parsing (race condition protection)
          if (requestId !== loadTargetsRequestId) {
            return; // stale response, ignore (newer request completed while we were parsing)
          }
          
          // reconcile: merge server data with optimistic updates
          // 1. Filter out optimistically removed items (even if server still has them)
          const filteredData = data.filter(t => {
            const pathLower = (t.path || '').toLowerCase();
            return !optimisticRemoves.has(pathLower);
          });
          
          // 2. Preserve optimistic additions that aren't yet in server response
          // IMPORTANT: read __targets BEFORE we update it, to capture current optimistic additions
          const currentTargets = __targets || [];
          const serverPaths = new Set(filteredData.map(t => (t.path || '').toLowerCase()));
          const optimisticAdditions = currentTargets.filter(t => {
            const pathLower = (t.path || '').toLowerCase();
            // keep if it's not in server response and looks like an optimistic add (empty fields)
            // also check it's not optimistically removed (safety check)
            return pathLower && !serverPaths.has(pathLower) && 
                   !optimisticRemoves.has(pathLower) &&
                   (!t.last_result && !t.sha256 && !t.mtime && !t.size);
          });
          
          // 3. Clear optimistic removes if server confirms removal (item not in response)
          const serverPathsSet = new Set(data.map(t => (t.path || '').toLowerCase()));
          optimisticRemoves.forEach(pathLower => {
            if (!serverPathsSet.has(pathLower)) {
              // server confirms removal, clear from tracking
              optimisticRemoves.delete(pathLower);
            }
          });
          
          // 4. Merge server data with optimistic additions
          // CRITICAL: mergedTargets already has optimistic removes filtered out
          const mergedTargets = [...filteredData, ...optimisticAdditions];
          __targets = mergedTargets;
          
          // 5. Get visible targets (double-check filtering - safety measure)
          const visibleTargets = getVisibleTargets(mergedTargets);
          
          // check if data actually changed using stable hash (on visible targets)
          const newHash = stableTargetsHash(visibleTargets);
          if (newHash !== __lastRenderedTargets) {
            // data changed - renderTargets will filter again and update __lastRenderedTargets
            if (state.tab === 'integrity') {
              renderTargets(mergedTargets); // renderTargets will apply getVisibleTargets internally
            }
          }
          
          // if this was a manual action, suppress polling
          // use longer suppression for removes to ensure server confirms before polling updates
          if (suppressPolling) {
            // check if we have optimistic removes - if so, use longer suppression (300ms for testing)
            // check BEFORE reconciliation, as reconciliation might clear some removes
            const hasOptimisticRemoves = optimisticRemoves.size > 0;
            const suppressionMs = hasOptimisticRemoves ? 300 : 200;
            // only extend suppression if not already set (optimisticRemoveTarget sets it immediately)
            if (Date.now() + suppressionMs > suppressPollingUntil) {
              suppressPollingUntil = Date.now() + suppressionMs;
            }
          }
        } catch (e) {
          // ignore aborted requests
          if (e.name === 'AbortError') {
            return;
          }
          // stale response check
          if (requestId !== loadTargetsRequestId) {
            return;
          }
          // Show error message in Integrity tab if it's active
          if (state.tab === 'integrity' && iTbody) {
            iTbody.innerHTML = `
              <tr>
                <td colspan="5" style="padding:20px;">
                  <div class="panel" style="max-width:600px; margin:0 auto;">
                    <div style="background:var(--bad); color:white; padding:12px; border-radius:8px; margin-bottom:16px;">
                      <div style="font-weight:600; font-size:16px; margin-bottom:8px; display:flex; align-items:center; justify-content:center; gap:8px;">
                        <img src="/static/assets/logo_warning.svg" alt="Warning" style="width:20px; height:20px; object-fit:contain;" />
                        Error Loading Integrity Targets
                      </div>
                      <div style="font-size:14px;">Failed to load monitored files from the server.</div>
                    </div>
                    <div class="small muted" style="text-align:left;">
                      <p><b>Error:</b> ${esc(e.message || 'Unknown error')}</p>
                      <p>This could happen if:</p>
                      <ul style="margin:8px 0; padding-left:20px;">
                        <li>CustosEye was shut down or crashed</li>
                        <li>There was a network error</li>
                        <li>The API endpoint is unavailable</li>
                      </ul>
                      <p style="margin-top:12px;">Try refreshing the page or restarting CustosEye.</p>
                    </div>
                  </div>
                </td>
              </tr>
            `;
          } else if (iTbody) {
            iTbody.innerHTML = `<tr><td colspan="5" class="small">Failed to load targets</td></tr>`;
          }
        }
      }, 200); // 200ms debounce
    }
    
    // optimistic UI update: add item immediately
    function optimisticAddTarget(target) {
      if (!Array.isArray(__targets)) {
        __targets = [];
      }
      const pathLower = (target.path || '').toLowerCase();
      // clear optimistic remove tracking if this path was previously removed
      optimisticRemoves.delete(pathLower);
      // immediately suppress polling to prevent interference (250ms window)
      suppressPollingUntil = Date.now() + 250;
      // check if already exists
      const exists = __targets.some(t => (t.path || '').toLowerCase() === pathLower);
      if (!exists) {
        __targets = [...__targets, target];
        // update hash immediately with visible targets
        const visibleTargets = getVisibleTargets(__targets);
        __lastRenderedTargets = stableTargetsHash(visibleTargets);
        if (state.tab === 'integrity') {
          renderTargets(__targets);
        }
      }
    }
    
    // optimistic UI update: remove item immediately
    function optimisticRemoveTarget(path) {
      if (!Array.isArray(__targets)) {
        return;
      }
      const pathLower = (path || '').toLowerCase();
      // track this removal
      optimisticRemoves.add(pathLower);
      // immediately suppress polling to prevent interference (1 second window)
      suppressPollingUntil = Date.now() + 1000;
      // filter out the removed item
      __targets = __targets.filter(t => (t.path || '').toLowerCase() !== pathLower);
      // update hash immediately with filtered data
      const visibleTargets = getVisibleTargets(__targets);
      // force update by clearing the last rendered hash so renderTargets will update
      __lastRenderedTargets = null;
      if (state.tab === 'integrity') {
        renderTargets(__targets);
      }
    }

    // get visible targets: always filter out optimistically removed items
    // this is the single source of truth for what should be displayed
    function getVisibleTargets(sourceList) {
      if (!Array.isArray(sourceList)) {
        return [];
      }
      // filter out any optimistically removed items
      return sourceList.filter(t => {
        const pathLower = (t.path || '').toLowerCase();
        return pathLower && !optimisticRemoves.has(pathLower);
      });
    }
    
    // render integrity targets table with status, actions, and baseline info
    function renderTargets(list) {
      // CRITICAL: always filter out optimistically removed items before rendering
      // This ensures removed items can never reappear until server confirms removal
      const visibleList = getVisibleTargets(list);
      
      // use stable hash for change detection (sorted, deterministic)
      const targetsHash = stableTargetsHash(visibleList);
      
      // only render if data has changed
      if (targetsHash === __lastRenderedTargets && __lastRenderedTargets !== null) {
        return; // data hasn't changed, skip rendering
      }
      __lastRenderedTargets = targetsHash;
      
      if (visibleList.length === 0) {
        requestAnimationFrame(() => {
          iTbody.innerHTML = `<tr><td colspan="5" class="small">No files being watched yet.</td></tr>`;
        });
        return;
      }

      // sort list by path to match stable hash ordering (prevents flicker from reordering)
      const sortedList = [...visibleList].sort((a, b) => {
        const pathA = (a.path || '').toLowerCase();
        const pathB = (b.path || '').toLowerCase();
        return pathA.localeCompare(pathB);
      });

      // use requestAnimationFrame for smoother updates
      const html = sortedList.map(row => {
        const note = (row.note || '').trim();
        const pathCell = `
          <td class="baseline-cell">
            <div class="baseline">
              <span class="mono mono-wrap">${row.path || ''}</span>
              ${note ? `<span class="small muted">Note: ${note}</span>` : ''}
            </div>
          </td>`;
        const ruleCell = `<td>${row.rule || 'sha256'}</td>`;

        // format baseline based on rule type (sha256 hash vs mtime+size)
        const baselineRaw = row.rule === 'sha256'
          ? (row.sha256 || '')
          : ((row.mtime && row.size) ? `mtime=${row.mtime} size=${row.size}` : '(none)');
        const baselineCell = `
          <td class="baseline-cell">
            <div class="baseline">
              <span class="mono mono-wrap">${baselineRaw}</span>
            </div>
          </td>`;

        const status = row.last_result || '';
        const { main: statusMain, note: statusNote } = splitStatus(status);
        
        // Check if file is deleted
        const isDeleted = statusMain.toUpperCase().includes('DELETED') || statusMain.toUpperCase().includes('MISSING');
        const badgeCls = statusMain.toUpperCase().startsWith('OK') ? 'ok' : (status ? 'bad' : '');
        const statusHTML = status
          ? `<div class="status">
              <span class="badge ${badgeCls}">${statusMain}</span>
              ${statusNote ? `<span class="small muted">${statusNote}</span>` : ''}
              ${isDeleted ? `<span class="badge" style="background:var(--bad); margin-left:8px;">DELETED</span>` : ''}
            </div>`
          : '';
        const statusCell = `<td>${statusHTML}</td>`;

        const showView = (statusMain || '').toUpperCase().startsWith('CHANGED') || isDeleted;
        const hasBaselineBlob = !!(row.baseline_blob && !row.baseline_blob.error);

        const actionsCell = `
          <td>
            <div class="row-actions">
              ${showView ? `<button class="btn" data-act="viewdiff" data-path="${encodeURIComponent(row.path || '')}">View changes</button>` : ''}
              ${hasBaselineBlob ? `<button class="btn" data-act="downloadBaseline" data-path="${encodeURIComponent(row.path || '')}">Download baseline</button>` : ''}
              <button class="btn" data-act="rehash" data-path="${encodeURIComponent(row.path || '')}" title="Retest this file if you think something has changed, or to confirm and update the baseline after reviewing changes you made intentionally.">Retest</button>
              <button class="btn" data-act="remove" data-path="${encodeURIComponent(row.path || '')}">Remove</button>
            </div>
          </td>`;

        return `<tr>${pathCell}${ruleCell}${baselineCell}${statusCell}${actionsCell}</tr>`;
      }).join('');
      
      // update table content with smooth transition using requestAnimationFrame
      requestAnimationFrame(() => {
        iTbody.innerHTML = html;
        
        // wire up event listeners after DOM update
        iTbody.querySelectorAll('button[data-act="downloadBaseline"]').forEach(btn => {
          btn.addEventListener('click', () => {
            const path = decodeURIComponent(btn.getAttribute('data-path'));
            window.location.href = `/api/integrity/baseline/download?path=${encodeURIComponent(path)}`;
          });
        });

        // wire up action buttons after rendering the table
        window.currentDiffPath = null;
        window.diffAutoRefreshInterval = null;
        
        // view changes button: show file diff in a modal dialog
        iTbody.querySelectorAll('button[data-act="viewdiff"]').forEach(btn => {
        btn.addEventListener('click', async () => {
          const path = decodeURIComponent(btn.getAttribute('data-path'));
          window.currentDiffPath = path;
          
          // clear any existing auto-refresh timer
          if (window.diffAutoRefreshInterval) {
            clearInterval(window.diffAutoRefreshInterval);
            window.diffAutoRefreshInterval = null;
          }
          
          // show modal immediately with loading state
          showModal('File changes', '<div class="small">Loading diff...</div>');
          
          // fetch and render the file diff
          async function loadDiff() {
            try {
              const r = await fetch('/api/integrity/diff', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({ path, max_regions: 50 })
              });
              const j = await r.json();
              
              // Handle deleted files
              if (j.file_deleted || j.error?.includes('deleted') || j.error?.includes('missing')) {
                if (modal.style.display !== 'none') {
                  const pathForDisplay = decodeURIComponent(path);
                  modalBody.innerHTML = `
                    <div style="padding:20px;">
                      <div style="background:var(--bad); color:white; padding:12px; border-radius:8px; margin-bottom:16px;">
                        <div style="font-weight:600; font-size:16px; margin-bottom:8px; display:flex; align-items:center; gap:6px;"><img src="/static/assets/warning.svg" alt="Warning" style="width:20px; height:20px; object-fit:contain;" /> File Deleted</div>
                        <div style="font-size:14px;">The file <span class="mono">${esc(pathForDisplay)}</span> has been deleted or is missing.</div>
                      </div>
                      <div style="padding:12px; background:var(--panel); border:1px solid var(--border); border-radius:8px; margin-bottom:16px;">
                        <div style="font-weight:600; margin-bottom:8px;">This deletion was intentional</div>
                        <div class="small muted" style="margin-bottom:12px;">If you intentionally deleted this file, click here to mark it as safe and remove it from the watch list.</div>
                        <button class="btn" id="acceptDeletionBtn" data-path="${encodeURIComponent(pathForDisplay)}" style="background:var(--bad); color:white;">
                          Mark Deletion as Safe
                        </button>
                      </div>
                      <div class="small muted">
                        <p><b>What happened:</b> The file that was being monitored for integrity has been deleted from the filesystem.</p>
                        <p><b>What you can do:</b> If this deletion was intentional, mark it as safe. If it was unexpected, investigate the deletion.</p>
                      </div>
                    </div>
                  `;
                  
                  // Wire deletion acceptance button
                  const acceptDeletionBtn = modalBody.querySelector('#acceptDeletionBtn');
                  if (acceptDeletionBtn) {
                    acceptDeletionBtn.addEventListener('click', async () => {
                      const btnPath = decodeURIComponent(acceptDeletionBtn.getAttribute('data-path') || path);
                      
                      // Show confirmation dialog before accepting
                      const confirmed = await showMarkIntentionalConfirmation(btnPath, true);
                      if (!confirmed) return;
                      
                      acceptDeletionBtn.disabled = true;
                      acceptDeletionBtn.textContent = 'Removing...';
                      
                      try {
                        const resp = await fetch('/api/integrity/baseline/accept', {
                          method: 'POST',
                          headers: {'Content-Type': 'application/json'},
                          body: JSON.stringify({ path: btnPath })
                        });
                        const result = await resp.json();
                        
                        if (result.ok) {
                          acceptDeletionBtn.textContent = 'Removed ✓';
                          acceptDeletionBtn.style.background = 'var(--good)';
                          
                          // Reload targets to update status (with suppression)
                          loadTargets(true);
                          
                          // Refresh Live Events to show updated status
                          fetchData();
                          
                          // Close modal after a short delay
                          setTimeout(() => {
                            hideModal();
                          }, 1500);
                        } else {
                          acceptDeletionBtn.textContent = 'Error: ' + (result.error || 'Failed');
                          acceptDeletionBtn.disabled = false;
                        }
                      } catch (e) {
                        acceptDeletionBtn.textContent = 'Error: ' + e.message;
                        acceptDeletionBtn.disabled = false;
                      }
                    });
                  }
                }
                return;
              }
              
              if (modal.style.display !== 'none') {
                // Preserve button states before re-rendering
                // Store which panels were expanded (formatting vs images)
                const wasFormattingExpanded = modalBody.querySelector('[id*="formatting-changes"][id*="-toggle"][data-expanded="true"]') !== null;
                const wasImagesExpanded = modalBody.querySelector('[id*="image-changes"][id*="-toggle"][data-expanded="true"]') !== null;
                
                // Preserve scroll positions of diff sides before re-rendering
                const oldDiffSides = modalBody.querySelectorAll('.diff-side .diff-lines');
                const scrollPositions = [];
                oldDiffSides.forEach(side => {
                  scrollPositions.push({
                    scrollTop: side.scrollTop,
                    scrollLeft: side.scrollLeft
                  });
                });
                
                const diffHTML = renderDiff(j);
                modalBody.innerHTML = diffHTML;
                
                // Restore scroll positions after rendering
                // First try to restore from sessionStorage (for navigation away/back)
                let savedScrollPositions = null;
                try {
                  const saved = sessionStorage.getItem(`diff-scroll-${path}`);
                  if (saved) {
                    savedScrollPositions = JSON.parse(saved);
                  }
                } catch (e) {
                  // ignore storage errors
                }
                
                // Use saved positions if available (for first open or navigation back), otherwise use current positions (for re-render)
                const positionsToRestore = savedScrollPositions || (scrollPositions.length > 0 ? scrollPositions : null);
                
                const newDiffSides = modalBody.querySelectorAll('.diff-side .diff-lines');
                if (positionsToRestore && newDiffSides.length > 0) {
                  // Use multiple requestAnimationFrame calls to ensure DOM is fully rendered and layout is complete
                  requestAnimationFrame(() => {
                    requestAnimationFrame(() => {
                      newDiffSides.forEach((side, index) => {
                        if (positionsToRestore[index]) {
                          side.scrollTop = positionsToRestore[index].scrollTop;
                          side.scrollLeft = positionsToRestore[index].scrollLeft;
                        }
                      });
                    });
                  });
                }
                
                // Also save current scroll positions on scroll events for persistence
                newDiffSides.forEach((side) => {
                  side.addEventListener('scroll', () => {
                    if (window.currentDiffPath) {
                      const currentPositions = [];
                      modalBody.querySelectorAll('.diff-side .diff-lines').forEach(s => {
                        currentPositions.push({
                          scrollTop: s.scrollTop,
                          scrollLeft: s.scrollLeft
                        });
                      });
                      try {
                        sessionStorage.setItem(`diff-scroll-${window.currentDiffPath}`, JSON.stringify(currentPositions));
                      } catch (e) {
                        // ignore storage errors
                      }
                    }
                  }, { passive: true });
                });
                
                // Restore button states after re-rendering
                // Find the new buttons and restore their state
                if (wasFormattingExpanded) {
                  const formattingToggle = modalBody.querySelector('[id*="formatting-changes"][id*="-toggle"]');
                  if (formattingToggle) {
                    const formattingHidden = modalBody.querySelector('[id*="formatting-changes"][id*="-hidden"]');
                    if (formattingHidden) {
                      formattingHidden.style.display = 'block';
                      formattingToggle.setAttribute('data-expanded', 'true');
                      formattingToggle.textContent = 'Show less';
                    }
                  }
                }
                
                if (wasImagesExpanded) {
                  const imagesToggle = modalBody.querySelector('[id*="image-changes"][id*="-toggle"]');
                  if (imagesToggle) {
                    const imagesHidden = modalBody.querySelector('[id*="image-changes"][id*="-hidden"]');
                    if (imagesHidden) {
                      imagesHidden.style.display = 'block';
                      imagesToggle.setAttribute('data-expanded', 'true');
                      imagesToggle.textContent = 'Show less';
                    }
                  }
                }
                
                // Wire "Change is OK" buttons after rendering
                const acceptBtn = modalBody.querySelector('#acceptBaselineBtn');
                const acceptBtnBinary = modalBody.querySelector('#acceptBaselineBtnBinary');
                
                function wireAcceptButton(btn, btnPath) {
                  if (!btn) return;
                  btn.addEventListener('click', async () => {
                    const buttonPath = btnPath || decodeURIComponent(btn.getAttribute('data-path') || path);
                    
                    // Show confirmation dialog before accepting
                    const confirmed = await showMarkIntentionalConfirmation(buttonPath);
                    if (!confirmed) return;
                    
                    btn.disabled = true;
                    btn.textContent = 'Updating...';
                    
                    try {
                      const resp = await fetch('/api/integrity/baseline/accept', {
                        method: 'POST',
                        headers: {'Content-Type': 'application/json'},
                        body: JSON.stringify({ path: buttonPath })
                      });
                      const result = await resp.json();
                      
                      if (result.ok) {
                        btn.textContent = 'Baseline Updated ✓';
                        btn.style.background = 'var(--good)';
                        
                        // Reload targets to update status (with suppression)
                        loadTargets(true);
                        
                        // Refresh Live Events to show updated status
                        fetchData();
                        
                        // Close modal after a short delay
                        setTimeout(() => {
                          hideModal();
                        }, 1500);
                      } else {
                        btn.textContent = 'Error: ' + (result.error || 'Failed');
                        btn.disabled = false;
                      }
                    } catch (e) {
                      btn.textContent = 'Error: ' + e.message;
                      btn.disabled = false;
                    }
                  });
                }
                
                if (acceptBtn) wireAcceptButton(acceptBtn, path);
                if (acceptBtnBinary) wireAcceptButton(acceptBtnBinary, path);
              }
            } catch (e) {
              if (modal.style.display !== 'none') {
                modalBody.innerHTML = `
                  <div style="padding:20px;">
                    <div style="background:var(--bad); color:white; padding:12px; border-radius:8px; margin-bottom:16px;">
                      <div style="font-weight:600; font-size:16px; margin-bottom:8px; display:flex; align-items:center; gap:8px;">
                        <img src="/static/assets/logo_warning.svg" alt="Warning" style="width:20px; height:20px; object-fit:contain;" />
                        Error Loading Diff
                      </div>
                      <div style="font-size:14px;">Failed to compute diff for this file.</div>
                    </div>
                    <div class="small muted">
                      <p><b>Error:</b> ${esc(e.message || 'Unknown error')}</p>
                      <p>This could happen if:</p>
                      <ul style="margin:8px 0; padding-left:20px;">
                        <li>The file was deleted or moved</li>
                        <li>The baseline data is missing or corrupted</li>
                        <li>There was a network error</li>
                      </ul>
                      <p style="margin-top:12px;">Try clicking "Retest" to regenerate the baseline, or check if the file still exists.</p>
                    </div>
                  </div>
                `;
              }
            }
          }
          
          // Load diff immediately
          await loadDiff();
          
          // Disable auto-refresh to prevent flickering
          // Auto-refresh was causing flickering every 5 seconds
          // Users can manually refresh by closing and reopening the modal if needed
          window.diffAutoRefreshInterval = null;
        });
      });

        // retest button: rehash file and update baseline if needed
        iTbody.querySelectorAll('button[data-act="rehash"]').forEach(btn => {
          btn.addEventListener('click', async () => {
            const path = decodeURIComponent(btn.getAttribute('data-path'));
            btn.disabled = true;
            const originalText = btn.textContent;
            btn.textContent = 'Retesting...';
            
            try {
              const r = await fetch('/api/integrity/hash', {
                method:'POST',
                headers:{'Content-Type':'application/json'},
                body: JSON.stringify({ path })
              });
              const j = await r.json();
              
              // Show status result with proper color coding
              if (j.last_result) {
                const status = j.last_result;
                if (status.toUpperCase().startsWith('OK')) {
                  await showIntegrityResult(status, 'Baseline confirmed, no changes detected.', 'The file matches its baseline hash.');
                } else if (status.toUpperCase().startsWith('CHANGED')) {
                  await showIntegrityResult(status, 'Changes detected in the file.', 'Click "View changes" to review the differences.');
                } else if (j.error) {
                  await showIntegrityResult('ERR', `Error: ${j.error}`, 'The file could not be checked.');
                } else {
                  await showIntegrityResult(status, 'File check completed.', '');
                }
              } else if (j.error) {
                await showIntegrityResult('ERR', `Error: ${j.error}`, 'The file could not be checked.');
              } else {
                // Fallback to hash display
                await showIntegrityResult('OK', `SHA-256: ${j.sha256 || 'No hash'}`, 'Hash computed successfully.');
              }
              
              // Reload targets to refresh status (with suppression)
              loadTargets(true);
            } catch (e) {
              await showIntegrityResult('ERR', `Error: ${e.message}`, 'An error occurred while checking the file.');
            } finally {
              btn.disabled = false;
              btn.textContent = originalText;
            }
          });
        });

        // remove button: delete target from watch list
        iTbody.querySelectorAll('button[data-act="remove"]').forEach(btn => {
          btn.addEventListener('click', async () => {
            const path = decodeURIComponent(btn.getAttribute('data-path'));
            const confirmed = await showRemoveConfirmation(path);
            if (!confirmed) return;
            
            // optimistic UI update: remove item immediately
            optimisticRemoveTarget(path);
            
            try {
              const response = await fetch('/api/integrity/targets', {
                method:'DELETE',
                headers:{'Content-Type':'application/json'},
                body: JSON.stringify({ path })
              });
              const result = await response.json();
              if (result.ok) {
                // reload with suppression to prevent polling interference (1s for removes)
                loadTargets(true);
              } else {
                // error - revert optimistic update
                optimisticRemoves.delete((path || '').toLowerCase());
                loadTargets(true);
              }
            } catch (e) {
              // error - revert optimistic update
              optimisticRemoves.delete((path || '').toLowerCase());
              loadTargets(true);
            }
          });
        });
      });
    }

    // browse button: open Windows file picker dialog
    iBrowse.addEventListener('click', async () => {
      iHint.textContent = 'Opening Windows file dialog...';
      try {
        const r = await fetch('/api/integrity/browse', { method:'POST' });
        const j = await r.json();
        if (j.path) { iPath.value = j.path; iHint.textContent = ''; } else { iHint.textContent = 'No file selected'; }
      } catch(e) { iHint.textContent = 'Browse not available'; }
    });

    // helper: show loading state on button while async operation runs
    function withBusy(btn, fn){
    const wasDisabled = btn.disabled;
    btn.disabled = true;
    btn.setAttribute('aria-busy','true');
    return Promise.resolve()
      .then(fn)
      .finally(()=>{
        btn.disabled = wasDisabled;
        btn.removeAttribute('aria-busy');
      });
  }

    iHash.addEventListener('click', () => withBusy(iHash, async () => {
      const path = iPath.value.trim();
      if (!path) { iHint.textContent = 'Pick a file first'; return; }
      iHint.textContent = 'Hashing...';
      const r = await fetch('/api/integrity/hash', {
        method:'POST',
        headers:{'Content-Type':'application/json'},
        body: JSON.stringify({path})
      });
      const j = await r.json();
      if (j.sha256) {
        iPreview.textContent = `SHA-256: ${j.sha256}  |  size=${j.size}  |  mtime=${j.mtime}`;
        iHint.textContent = 'Preview ready';
      } else {
        iPreview.textContent = '';
        iHint.textContent = j.error || 'Failed to hash';
      }
    }));

    iAdd.addEventListener('click', () => withBusy(iAdd, async () => {
      const path = iPath.value.trim();
      if (!path) { iHint.textContent = 'Pick a file first'; return; }
      const rule = iRule.value;
      const note = iNote.value.trim();
      iHint.textContent = 'Saving...';
      
      // optimistic UI update: add item immediately
      const optimisticTarget = {
        path: path,
        rule: rule,
        note: note,
        last_result: '',
        sha256: '',
        mtime: '',
        size: ''
      };
      optimisticAddTarget(optimisticTarget);
      
      try {
        const r = await fetch('/api/integrity/targets', {
          method:'POST',
          headers:{'Content-Type':'application/json'},
          body: JSON.stringify({path, rule, note})
        });
        const j = await r.json();
        if (j.ok) {
          iHint.textContent = 'Saved';
          iPreview.textContent = '';
          iNote.value = '';
          iPath.value = '';                 // clear so placeholder shows again
          iPath.dispatchEvent(new Event('input'));
          iPath.blur();
          // reload with suppression to prevent polling interference
          loadTargets(true);
        } else {
          iHint.textContent = j.error || 'Failed to save';
          // revert optimistic update on error
          optimisticRemoveTarget(path);
          loadTargets(true);
        }
      } catch (e) {
        iHint.textContent = 'Failed to save: ' + e.message;
        // revert optimistic update on error
        optimisticRemoveTarget(path);
        loadTargets(true);
      }
    }));

    // background polling: continuously fetch data and update all tabs (but only render the active one)
    let inFlight = false;
    let lastTreeAt = 0;
    let pollCtrl = null;

    // check if we're in preview mode (loaded in iframe for login background)
    const isPreview = window.self !== window.top || window.location.pathname === '/preview';
    
    // if in preview mode, disable interactions and make read-only
    if (isPreview) {
      document.body.style.pointerEvents = 'none';
      document.body.style.userSelect = 'none';
      // hide logout button and 2FA button in preview
      const logoutBtn = document.getElementById('logoutBtn');
      if (logoutBtn) logoutBtn.style.display = 'none';
      const fa2Btn = document.querySelector('a[href="/auth/enable-2fa"]');
      if (fa2Btn) fa2Btn.style.display = 'none';
    }
    
    // polling tick: fetch events, integrity targets, about info, and optionally process tree
    async function tick() {
      if (state.paused || inFlight) return;
      inFlight = true;

      if (pollCtrl && pollCtrl.abort) pollCtrl.abort();
      const AC = window.AbortController;
      pollCtrl = AC ? new AC() : null;

      try {
        const wantsTree = state.tab === 'tree';
        const now = Date.now();
        const needTree = wantsTree || (now - lastTreeAt > 8000); // every 8s if not on tab
        const includeInfo = '1';

        // in preview mode, use preview API endpoints that don't require auth
        const jobs = [
          fetch(isPreview ? `/api/preview/events?include_info=${includeInfo}` : `/api/events?include_info=${includeInfo}`, { signal: pollCtrl?.signal }).catch(e => ({ ok: false, error: e, json: async () => [] })), // 0
          fetch(isPreview ? `/api/preview/integrity/targets` : `/api/integrity/targets`,                 { signal: pollCtrl?.signal }).catch(e => ({ ok: false, error: e, json: async () => [] })),   // 1
          fetch(isPreview ? `/api/preview/about` : `/api/about`,                             { signal: pollCtrl?.signal }).catch(e => ({ ok: false, error: e, json: async () => ({version: 'preview'}) })),   // 2
          fetch(`/api/ping`,                              { signal: pollCtrl?.signal }).catch(() => ({ ok: true })) // 3
        ];
        if (needTree) {
          jobs.push(
            fetch(isPreview ? `/api/preview/proctree` : `/api/proctree`, { signal: pollCtrl?.signal }).then(r => {
              lastTreeAt = now;
              return r;
            }).catch(e => ({ ok: false, error: e, json: async () => [] })) // 4
          );
        }

        const results = await Promise.allSettled(jobs);

        const evR    = results[0];
        const targR  = results[1];
        const aboutR = results[2];
        const treeR  = needTree ? results[4] : null;

        // Handle events data
        if (evR?.status === 'fulfilled') {
          const evRes = evR.value;
          if (evRes.ok !== false && evRes.ok !== undefined) {
            // Check if it's a real Response object
            if (evRes instanceof Response) {
              if (evRes.ok) {
                __events = await evRes.json();
              } else if (state.tab === 'live') {
                // HTTP error response
                const liveEl = document.getElementById('live');
                if (liveEl) {
                  liveEl.innerHTML = `
                    <div style="padding:20px;">
                      <div class="panel" style="max-width:600px; margin:0 auto;">
                        <div style="background:var(--bad); color:white; padding:12px; border-radius:8px; margin-bottom:16px;">
                          <div style="font-weight:600; font-size:16px; margin-bottom:8px; display:flex; align-items:center; justify-content:center; gap:8px;">
                            <img src="/static/assets/logo_warning.svg" alt="Warning" style="width:20px; height:20px; object-fit:contain;" />
                            Error Loading Live Events
                          </div>
                          <div style="font-size:14px;">Failed to load events from the server.</div>
                        </div>
                        <div class="small muted" style="text-align:left;">
                          <p><b>Error:</b> HTTP ${evRes.status}: ${evRes.statusText || 'Server error'}</p>
                          <p>This could happen if:</p>
                          <ul style="margin:8px 0; padding-left:20px;">
                            <li>CustosEye was shut down or crashed</li>
                            <li>There was a network error</li>
                            <li>The API endpoint is unavailable</li>
                          </ul>
                          <p style="margin-top:12px;">Try refreshing the page or restarting CustosEye.</p>
                        </div>
                      </div>
                    </div>
                  `;
                }
              }
            } else {
              // Not a Response object, treat as data
              __events = await evRes.json();
            }
          } else if (evRes.error && state.tab === 'live') {
            // Show error if Live Events tab is active
            const liveEl = document.getElementById('live');
            if (liveEl) {
              liveEl.innerHTML = `
                <div style="padding:20px;">
                  <div class="panel" style="max-width:600px; margin:0 auto;">
                    <div style="background:var(--bad); color:white; padding:12px; border-radius:8px; margin-bottom:16px;">
                      <div style="font-weight:600; font-size:16px; margin-bottom:8px; display:flex; align-items:center; justify-content:center; gap:8px;">
                        <img src="/static/assets/logo_warning.svg" alt="Warning" style="width:20px; height:20px; object-fit:contain;" />
                        Error Loading Live Events
                      </div>
                      <div style="font-size:14px;">Failed to load events from the server.</div>
                    </div>
                    <div class="small muted" style="text-align:left;">
                      <p><b>Error:</b> ${esc(evRes.error?.message || 'Connection failed')}</p>
                      <p>This could happen if:</p>
                      <ul style="margin:8px 0; padding-left:20px;">
                        <li>CustosEye was shut down or crashed</li>
                        <li>There was a network error</li>
                        <li>The API endpoint is unavailable</li>
                      </ul>
                      <p style="margin-top:12px;">Try refreshing the page or restarting CustosEye.</p>
                    </div>
                  </div>
                </div>
              `;
            }
          }
        }
        // only update targets from polling if not in suppression window (after manual actions)
        if (targR?.status === 'fulfilled' && Date.now() >= suppressPollingUntil) {
          const targRes = targR.value;
          // Check for errors (network errors or HTTP errors)
          if (targRes.error && state.tab === 'integrity' && iTbody) {
            // Show error if Integrity tab is active
            iTbody.innerHTML = `
              <tr>
                <td colspan="5" style="padding:20px;">
                  <div class="panel" style="max-width:600px; margin:0 auto;">
                    <div style="background:var(--bad); color:white; padding:12px; border-radius:8px; margin-bottom:16px;">
                      <div style="font-weight:600; font-size:16px; margin-bottom:8px; display:flex; align-items:center; justify-content:center; gap:8px;">
                        <img src="/static/assets/logo_warning.svg" alt="Warning" style="width:20px; height:20px; object-fit:contain;" />
                        Error Loading Integrity Targets
                      </div>
                      <div style="font-size:14px;">Failed to load monitored files from the server.</div>
                    </div>
                    <div class="small muted" style="text-align:left;">
                      <p><b>Error:</b> ${esc(targRes.error?.message || 'Connection failed')}</p>
                      <p>This could happen if:</p>
                      <ul style="margin:8px 0; padding-left:20px;">
                        <li>CustosEye was shut down or crashed</li>
                        <li>There was a network error</li>
                        <li>The API endpoint is unavailable</li>
                      </ul>
                      <p style="margin-top:12px;">Try refreshing the page or restarting CustosEye.</p>
                    </div>
                  </div>
                </td>
              </tr>
            `;
            return; // Don't process data if there was an error
          }
          // Check if it's a real Response object with HTTP error
          if (targRes instanceof Response && !targRes.ok && state.tab === 'integrity' && iTbody) {
            iTbody.innerHTML = `
              <tr>
                <td colspan="5" style="padding:20px;">
                  <div class="panel" style="max-width:600px; margin:0 auto;">
                    <div style="background:var(--bad); color:white; padding:12px; border-radius:8px; margin-bottom:16px;">
                      <div style="font-weight:600; font-size:16px; margin-bottom:8px; display:flex; align-items:center; justify-content:center; gap:8px;">
                        <img src="/static/assets/logo_warning.svg" alt="Warning" style="width:20px; height:20px; object-fit:contain;" />
                        Error Loading Integrity Targets
                      </div>
                      <div style="font-size:14px;">Failed to load monitored files from the server.</div>
                    </div>
                    <div class="small muted" style="text-align:left;">
                      <p><b>Error:</b> HTTP ${targRes.status}: ${targRes.statusText || 'Server error'}</p>
                      <p>This could happen if:</p>
                      <ul style="margin:8px 0; padding-left:20px;">
                        <li>CustosEye was shut down or crashed</li>
                        <li>There was a network error</li>
                        <li>The API endpoint is unavailable</li>
                      </ul>
                      <p style="margin-top:12px;">Try refreshing the page or restarting CustosEye.</p>
                    </div>
                  </div>
                </td>
              </tr>
            `;
            return; // Don't process data if there was an error
          }
          if (!(targRes instanceof Response) || !targRes.ok) {
            return; // Skip if not OK and not showing error (tab not active)
          }
          const pollingData = await targRes.json();
          // reconcile polling data with optimistic updates (same logic as loadTargets)
          // 1. Filter out optimistically removed items (CRITICAL: prevents removed items from reappearing)
          const filteredData = pollingData.filter(t => {
            const pathLower = (t.path || '').toLowerCase();
            return !optimisticRemoves.has(pathLower);
          });
          // 2. Preserve optimistic additions that aren't yet in server response
          // IMPORTANT: read __targets BEFORE we update it, to capture current optimistic additions
          const currentTargets = __targets || [];
          const serverPaths = new Set(filteredData.map(t => (t.path || '').toLowerCase()));
          const optimisticAdditions = currentTargets.filter(t => {
            const pathLower = (t.path || '').toLowerCase();
            // keep if it's not in server response and looks like an optimistic add (empty fields)
            // also check it's not optimistically removed (safety check)
            return pathLower && !serverPaths.has(pathLower) && 
                   !optimisticRemoves.has(pathLower) &&
                   (!t.last_result && !t.sha256 && !t.mtime && !t.size);
          });
          // 3. Clear optimistic removes if server confirms removal (item not in response)
          const serverPathsSet = new Set(pollingData.map(t => (t.path || '').toLowerCase()));
          optimisticRemoves.forEach(pathLower => {
            if (!serverPathsSet.has(pathLower)) {
              // server confirms removal, clear from tracking
              optimisticRemoves.delete(pathLower);
            }
          });
          // 4. Merge and update (filtered data + optimistic additions)
          __targets = [...filteredData, ...optimisticAdditions];
        }
        if (aboutR?.status === 'fulfilled') {
          const aboutRes = aboutR.value;
          // Skip error handling for About tab - just try to load data
          if (!aboutRes.error && (aboutRes instanceof Response ? aboutRes.ok : true)) {
            try {
              __about = await aboutRes.json();
              if (state.tab === 'about') {
                renderActive();
              }
            } catch (e) {
              // Silently ignore errors for About tab
            }
          }
        }

        if (needTree && treeR && treeR.status === 'fulfilled') {
          const treeRes = treeR.value;
          // Check if it's a real Response object
          if (treeRes instanceof Response) {
            if (treeRes.ok) {
              __tree = await treeRes.json();
              if (openKeys.size === 0 && Array.isArray(__tree)) {
                for (const root of __tree) openKeys.add(String(root.pid));
              }
            } else if (state.tab === 'tree') {
              // HTTP error response
              const treeRoot = document.getElementById('treeRoot');
              if (treeRoot) {
                treeRoot.innerHTML = `
                  <div style="padding:20px;">
                    <div class="panel" style="max-width:600px; margin:0 auto;">
                      <div style="background:var(--bad); color:white; padding:12px; border-radius:8px; margin-bottom:16px;">
                        <div style="font-weight:600; font-size:16px; margin-bottom:8px; display:flex; align-items:center; justify-content:center; gap:8px;">
                          <img src="/static/assets/logo_warning.svg" alt="Warning" style="width:20px; height:20px; object-fit:contain;" />
                          Error Loading Process Tree
                        </div>
                        <div style="font-size:14px;">Failed to load process tree from the server.</div>
                      </div>
                      <div class="small muted" style="text-align:left;">
                        <p><b>Error:</b> HTTP ${treeRes.status}: ${treeRes.statusText || 'Server error'}</p>
                        <p>This could happen if:</p>
                        <ul style="margin:8px 0; padding-left:20px;">
                          <li>CustosEye was shut down or crashed</li>
                          <li>There was a network error</li>
                          <li>The API endpoint is unavailable</li>
                        </ul>
                        <p style="margin-top:12px;">Try clicking "Refresh" or restarting CustosEye.</p>
                      </div>
                    </div>
                  </div>
                `;
              }
            }
          } else if (treeRes && (treeRes.error || treeRes.ok === false) && state.tab === 'tree') {
            // Show error if Process Tree tab is active (network error or failed response)
            const treeRoot = document.getElementById('treeRoot');
            if (treeRoot) {
              treeRoot.innerHTML = `
                <div style="padding:20px;">
                  <div class="panel" style="max-width:600px; margin:0 auto;">
                    <div style="background:var(--bad); color:white; padding:12px; border-radius:8px; margin-bottom:16px;">
                      <div style="font-weight:600; font-size:16px; margin-bottom:8px; display:flex; align-items:center; justify-content:center; gap:8px;">
                        <img src="/static/assets/logo_warning.svg" alt="Warning" style="width:20px; height:20px; object-fit:contain;" />
                        Error Loading Process Tree
                      </div>
                      <div style="font-size:14px;">Failed to load process tree from the server.</div>
                    </div>
                    <div class="small muted" style="text-align:left;">
                      <p><b>Error:</b> ${esc(treeRes.error?.message || 'Connection failed')}</p>
                      <p>This could happen if:</p>
                      <ul style="margin:8px 0; padding-left:20px;">
                        <li>CustosEye was shut down or crashed</li>
                        <li>There was a network error</li>
                        <li>The API endpoint is unavailable</li>
                      </ul>
                      <p style="margin-top:12px;">Try clicking "Refresh" or restarting CustosEye.</p>
                    </div>
                  </div>
                </div>
              `;
            }
          }
        }

        // save fresh data to cache for instant display on next navigation
        saveDataCache();
        
        if (needTree && state.tab === 'tree') {
          renderActive();
          inFlight = false;
          return;
        }

        renderActive();
      } catch (_e) {
        // ignore transient errors
      } finally {
        inFlight = false;
      }
    }

    // pause polling when browser tab is not visible to save resources
    document.addEventListener('visibilitychange', () => {
      if (document.hidden) {
        state.paused = true;
      } else {
        const savedPaused = localStorage.getItem('custoseye.paused');
        state.paused = savedPaused === 'true';
      }
      pauseBtn?.setAttribute('data-on', state.paused ? 'true' : 'false');
      if (pauseText) pauseText.textContent = state.paused ? 'Paused' : 'Live';
    });

    // avoid duplicate timers if this script runs twice
    if (state.timer) clearInterval(state.timer);

    // start the polling timer: fetch data every 1.5 seconds
    state.timer = setInterval(tick, 1500);

    // clean up the timer when leaving the page
    window.addEventListener('beforeunload', () => { 
      if (state.timer) clearInterval(state.timer);
      // Save scroll positions before page unload
      if (window.currentDiffPath && modal.style.display !== 'none') {
        const diffSides = modalBody.querySelectorAll('.diff-side .diff-lines');
        const scrollPositions = [];
        diffSides.forEach(side => {
          scrollPositions.push({
            scrollTop: side.scrollTop,
            scrollLeft: side.scrollLeft
          });
        });
        if (scrollPositions.length > 0) {
          try {
            sessionStorage.setItem(`diff-scroll-${window.currentDiffPath}`, JSON.stringify(scrollPositions));
          } catch (e) {
            // ignore storage errors
          }
        }
      }
    });

    // load cached data immediately for instant display when navigating back
    loadDataCache();

    // initial data fetch and render
    tick();
    
    // custom logout/shutdown dialog
    const logoutModal = document.createElement('div');
    logoutModal.id = 'logoutModal';
    logoutModal.className = 'hidden';
    logoutModal.style.cssText = 'position:fixed; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.7); display:none; align-items:center; justify-content:center; z-index:10000;';
    logoutModal.innerHTML = `
      <div class="panel" style="max-width:400px; position:relative; padding:24px;">
        <div id="logoutMessage" style="color:var(--text); margin-bottom:20px; font-size:14px; line-height:1.6; white-space:pre-line;"></div>
        <div style="display:flex; gap:8px; justify-content:flex-end; flex-wrap:wrap;">
          <button id="logoutCancel" class="btn" style="padding:8px 16px; width:auto; background:transparent; color:var(--muted); border:1px solid var(--border);">Cancel</button>
          <button id="logoutLogout" class="btn" style="padding:8px 16px; width:auto; background:var(--accent);">Logout</button>
          <button id="logoutShutdown" class="btn" style="padding:8px 16px; width:auto; background:var(--bad);">Shutdown</button>
        </div>
      </div>
    `;
    document.body.appendChild(logoutModal);
    
    const logoutMessage = document.getElementById('logoutMessage');
    const logoutCancel = document.getElementById('logoutCancel');
    const logoutLogout = document.getElementById('logoutLogout');
    const logoutShutdown = document.getElementById('logoutShutdown');
    
    let logoutResolve = null;
    
    if (logoutCancel && logoutLogout && logoutShutdown) {
      logoutCancel.addEventListener('click', () => {
        logoutModal.style.display = 'none';
        logoutModal.classList.add('hidden');
        if (logoutResolve) {
          logoutResolve('cancel');
          logoutResolve = null;
        }
      });
      
      logoutLogout.addEventListener('click', () => {
        logoutModal.style.display = 'none';
        logoutModal.classList.add('hidden');
        if (logoutResolve) {
          logoutResolve('logout');
          logoutResolve = null;
        }
      });
      
      logoutShutdown.addEventListener('click', () => {
        logoutModal.style.display = 'none';
        logoutModal.classList.add('hidden');
        if (logoutResolve) {
          logoutResolve('shutdown');
          logoutResolve = null;
        }
      });
    }
    
    function showLogoutDialog(message) {
      return new Promise((resolve) => {
        logoutResolve = resolve;
        if (logoutMessage) {
          logoutMessage.textContent = message;
        }
        logoutModal.style.display = 'flex';
        logoutModal.classList.remove('hidden');
      });
    }
    
    // custom confirmation/alert dialogs (for other uses)
    const confirmModal = document.createElement('div');
    confirmModal.id = 'confirmModal';
    confirmModal.className = 'hidden';
    confirmModal.style.cssText = 'position:fixed; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.7); display:none; align-items:center; justify-content:center; z-index:10000;';
    confirmModal.innerHTML = `
      <div class="panel" style="max-width:520px; position:relative; padding:0; box-shadow:0 16px 48px rgba(0,0,0,0.5); overflow:hidden;">
        <div id="confirmMessage" style="color:var(--text); padding:0; font-size:14px; line-height:1.6; white-space:pre-line;"></div>
        <div style="display:flex; gap:10px; justify-content:flex-end; padding:16px 24px; border-top:1px solid var(--border); background:color-mix(in oklab, var(--panel) 95%, transparent);">
          <button id="confirmCancel" class="btn" style="padding:10px 20px; width:auto; background:transparent; color:var(--muted); border:1px solid var(--border); font-weight:500; transition:all 0.2s ease;">Cancel</button>
          <button id="confirmOk" class="btn" style="padding:10px 24px; width:auto; font-weight:500; transition:all 0.2s ease;">OK</button>
        </div>
      </div>
    `;
    document.body.appendChild(confirmModal);
    
    const confirmMessage = document.getElementById('confirmMessage');
    const confirmOk = document.getElementById('confirmOk');
    const confirmCancel = document.getElementById('confirmCancel');
    
    let confirmResolve = null;
    let currentModalType = 'confirm';
    
    if (confirmOk && confirmCancel) {
      const closeModal = () => {
        const panel = confirmModal.querySelector('.panel');
        if (panel) {
          panel.style.opacity = '0';
          panel.style.transform = 'scale(0.96) translateY(-4px)';
          setTimeout(() => {
            confirmModal.style.display = 'none';
            confirmModal.classList.add('hidden');
            // Reset animation for next time
            if (panel) {
              panel.style.opacity = '';
              panel.style.transform = '';
              panel.style.transition = '';
            }
          }, 150);
        } else {
          confirmModal.style.display = 'none';
          confirmModal.classList.add('hidden');
        }
      };
      
      confirmOk.addEventListener('click', () => {
        closeModal();
        if (confirmCancel) confirmCancel.style.display = 'flex';
        if (confirmResolve) {
          confirmResolve(true);
          confirmResolve = null;
        }
      });
      
      confirmCancel.addEventListener('click', () => {
        closeModal();
        if (confirmCancel) confirmCancel.style.display = 'flex';
        if (confirmResolve) {
          confirmResolve(currentModalType === 'alert' ? true : false);
          confirmResolve = null;
        }
      });
    }
    
    function showCustomConfirm(message) {
      return new Promise((resolve) => {
        confirmResolve = resolve;
        currentModalType = 'confirm';
        if (confirmMessage) {
          confirmMessage.textContent = message;
        }
        if (confirmCancel) confirmCancel.style.display = 'flex';
        confirmModal.style.display = 'flex';
        confirmModal.classList.remove('hidden');
      });
    }
    
    function showCustomAlert(message) {
      return new Promise((resolve) => {
        confirmResolve = resolve;
        currentModalType = 'alert';
        if (confirmMessage) {
          confirmMessage.textContent = message;
        }
        if (confirmCancel) confirmCancel.style.display = 'none';
        confirmModal.style.display = 'flex';
        confirmModal.classList.remove('hidden');
      });
    }
    
    // show styled integrity check result with elegant design
    function showIntegrityResult(status, message, details) {
      return new Promise((resolve) => {
        confirmResolve = resolve;
        currentModalType = 'alert';
        
        // Determine styling based on status
        let statusConfig = {
          logo: '',
          text: status,
          themeColor: 'var(--text)',
          modalBg: 'var(--panel)',
          modalBorder: 'var(--border)',
          buttonBg: 'var(--accent)',
          buttonAreaBg: 'var(--panel)'
        };
        
        if (status.toUpperCase().startsWith('OK')) {
          statusConfig = {
            logo: '/static/assets/logo_confirm.svg',
            text: 'Verified',
            themeColor: 'var(--good)',
            modalBg: 'color-mix(in oklab, var(--good) 20%, var(--panel))',
            modalBorder: 'color-mix(in oklab, var(--good) 60%, var(--border))',
            buttonBg: 'var(--good)',
            buttonAreaBg: 'color-mix(in oklab, var(--good) 18%, var(--panel))'
          };
        } else if (status.toUpperCase().startsWith('CHANGED') || status.toUpperCase().startsWith('ERR')) {
          statusConfig = {
            logo: '/static/assets/logo_warning.svg',
            text: status.toUpperCase().startsWith('CHANGED') ? 'File Changed' : 'Error',
            themeColor: 'var(--bad)',
            modalBg: 'color-mix(in oklab, var(--bad) 20%, var(--panel))',
            modalBorder: 'color-mix(in oklab, var(--bad) 60%, var(--border))',
            buttonBg: 'var(--bad)',
            buttonAreaBg: 'color-mix(in oklab, var(--bad) 18%, var(--panel))'
          };
        }
        
        if (confirmMessage) {
          confirmMessage.innerHTML = `
            <div style="padding:28px; text-align:center;">
              ${statusConfig.logo ? `
                <div style="margin:0 auto 20px; width:80px; height:80px; display:flex; align-items:center; justify-content:center; animation:logoPulse 0.5s ease-out;">
                  <img src="${statusConfig.logo}" alt="${statusConfig.text}" style="width:100%; height:100%; object-fit:contain; filter:drop-shadow(0 4px 12px rgba(0,0,0,0.3));" />
                </div>
              ` : ''}
              <div style="color:${statusConfig.themeColor}; font-size:22px; font-weight:700; letter-spacing:0.5px; margin-bottom:12px; text-transform:uppercase;">${statusConfig.text}</div>
              <div style="color:var(--text); font-size:15px; line-height:1.6; margin-bottom:${details ? '16px' : '0'}; max-width:400px; margin-left:auto; margin-right:auto;">${message}</div>
              ${details ? `<div style="color:var(--muted); font-size:13px; line-height:1.6; margin-top:16px; background:inherit !important; border:none; padding:0;">${details}</div>` : ''}
            </div>
            <style>
              @keyframes logoPulse {
                0% { transform: scale(0.85); opacity: 0; }
                50% { transform: scale(1.08); }
                100% { transform: scale(1); opacity: 1; }
              }
            </style>
          `;
        }
        
        if (confirmCancel) confirmCancel.style.display = 'none';
        confirmModal.style.display = 'flex';
        confirmModal.classList.remove('hidden');
        
        // Apply theme colors
        const panel = confirmModal.querySelector('.panel');
        const buttonArea = panel?.querySelector('div:last-child');
        const okButton = document.getElementById('confirmOk');
        
        if (panel) {
          panel.style.background = statusConfig.modalBg;
          panel.style.borderColor = statusConfig.modalBorder;
          panel.style.borderWidth = '2px';
        }
        
        if (buttonArea) {
          buttonArea.style.background = statusConfig.buttonAreaBg;
          buttonArea.style.borderColor = statusConfig.modalBorder;
        }
        
        if (okButton) {
          okButton.style.background = statusConfig.buttonBg;
          okButton.style.color = 'white';
          okButton.style.border = 'none';
        }
        
        // Fade-in animation
        if (panel) {
          panel.style.opacity = '0';
          panel.style.transform = 'scale(0.95) translateY(-6px)';
          panel.style.transition = 'opacity 0.25s ease, transform 0.25s ease';
          requestAnimationFrame(() => {
            panel.style.opacity = '1';
            panel.style.transform = 'scale(1) translateY(0)';
          });
        }
      });
    }
    
    // show removal confirmation with caution logo
    function showRemoveConfirmation(filePath) {
      return new Promise((resolve) => {
        confirmResolve = resolve;
        currentModalType = 'confirm';
        
        if (confirmMessage) {
          const shortPath = filePath.length > 50 ? '...' + filePath.slice(-47) : filePath;
          confirmMessage.innerHTML = `
            <div style="padding:28px; text-align:center;">
              <div style="margin:0 auto 20px; width:80px; height:80px; display:flex; align-items:center; justify-content:center; animation:logoPulse 0.5s ease-out;">
                <img src="/static/assets/logo_caution.svg" alt="Caution" style="width:100%; height:100%; object-fit:contain; filter:drop-shadow(0 4px 12px rgba(0,0,0,0.3));" />
              </div>
              <div style="color:var(--warn); font-size:22px; font-weight:700; letter-spacing:0.5px; margin-bottom:12px; text-transform:uppercase;">Remove File</div>
              <div style="color:var(--text); font-size:15px; line-height:1.6; margin-bottom:16px; max-width:400px; margin-left:auto; margin-right:auto;">Are you sure you want to remove this file from the watch list?</div>
              <div style="color:var(--muted); font-size:13px; line-height:1.6; padding:12px; background:color-mix(in oklab, var(--warn) 8%, var(--panel)); border-radius:8px; border:1px solid color-mix(in oklab, var(--warn) 20%, var(--border)); font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace; word-break:break-all;">${shortPath}</div>
            </div>
            <style>
              @keyframes logoPulse {
                0% { transform: scale(0.85); opacity: 0; }
                50% { transform: scale(1.08); }
                100% { transform: scale(1); opacity: 1; }
              }
            </style>
          `;
        }
        
        if (confirmCancel) confirmCancel.style.display = 'flex';
        confirmModal.style.display = 'flex';
        confirmModal.classList.remove('hidden');
        
        // Apply caution theme
        const panel = confirmModal.querySelector('.panel');
        const buttonArea = panel?.querySelector('div:last-child');
        const cancelButton = document.getElementById('confirmCancel');
        const okButton = document.getElementById('confirmOk');
        
        if (panel) {
          panel.style.background = 'color-mix(in oklab, var(--warn) 15%, var(--panel))';
          panel.style.borderColor = 'color-mix(in oklab, var(--warn) 50%, var(--border))';
          panel.style.borderWidth = '2px';
        }
        
        if (buttonArea) {
          buttonArea.style.background = 'color-mix(in oklab, var(--warn) 12%, var(--panel))';
          buttonArea.style.borderColor = 'color-mix(in oklab, var(--warn) 40%, var(--border))';
        }
        
        if (okButton) {
          okButton.style.background = 'var(--warn)';
          okButton.style.color = 'white';
          okButton.style.border = 'none';
        }
        
        if (cancelButton) {
          cancelButton.style.borderColor = 'color-mix(in oklab, var(--warn) 30%, var(--border))';
        }
        
        // Fade-in animation
        if (panel) {
          panel.style.opacity = '0';
          panel.style.transform = 'scale(0.95) translateY(-6px)';
          panel.style.transition = 'opacity 0.25s ease, transform 0.25s ease';
          requestAnimationFrame(() => {
            panel.style.opacity = '1';
            panel.style.transform = 'scale(1) translateY(0)';
          });
        }
      });
    }
    
    // show mark intentional confirmation with caution logo
    function showMarkIntentionalConfirmation(filePath, isDeletion = false) {
      return new Promise((resolve) => {
        confirmResolve = resolve;
        currentModalType = 'confirm';
        
        if (confirmMessage) {
          const shortPath = filePath.length > 50 ? '...' + filePath.slice(-47) : filePath;
          const actionText = isDeletion ? 'Mark Deletion as Intentional' : 'Mark Change as Intentional';
          const messageText = isDeletion 
            ? 'Are you sure you want to mark this file deletion as intentional? This will update the baseline and stop alerts.'
            : 'Are you sure you want to mark this change as intentional? This will update the baseline and stop alerts.';
          
          confirmMessage.innerHTML = `
            <div style="padding:28px; text-align:center;">
              <div style="margin:0 auto 20px; width:80px; height:80px; display:flex; align-items:center; justify-content:center; animation:logoPulse 0.5s ease-out;">
                <img src="/static/assets/logo_caution.svg" alt="Caution" style="width:100%; height:100%; object-fit:contain; filter:drop-shadow(0 4px 12px rgba(0,0,0,0.3));" />
              </div>
              <div style="color:var(--warn); font-size:22px; font-weight:700; letter-spacing:0.5px; margin-bottom:12px; text-transform:uppercase;">${actionText}</div>
              <div style="color:var(--text); font-size:15px; line-height:1.6; margin-bottom:16px; max-width:400px; margin-left:auto; margin-right:auto;">${messageText}</div>
              <div style="color:var(--muted); font-size:13px; line-height:1.6; padding:12px; background:color-mix(in oklab, var(--warn) 8%, var(--panel)); border-radius:8px; border:1px solid color-mix(in oklab, var(--warn) 20%, var(--border)); font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace; word-break:break-all;">${shortPath}</div>
            </div>
            <style>
              @keyframes logoPulse {
                0% { transform: scale(0.85); opacity: 0; }
                50% { transform: scale(1.08); }
                100% { transform: scale(1); opacity: 1; }
              }
            </style>
          `;
        }
        
        if (confirmCancel) confirmCancel.style.display = 'flex';
        confirmModal.style.display = 'flex';
        confirmModal.classList.remove('hidden');
        
        // Apply caution theme
        const panel = confirmModal.querySelector('.panel');
        const buttonArea = panel?.querySelector('div:last-child');
        const cancelButton = document.getElementById('confirmCancel');
        const okButton = document.getElementById('confirmOk');
        
        if (panel) {
          panel.style.background = 'color-mix(in oklab, var(--warn) 15%, var(--panel))';
          panel.style.borderColor = 'color-mix(in oklab, var(--warn) 50%, var(--border))';
          panel.style.borderWidth = '2px';
        }
        
        if (buttonArea) {
          buttonArea.style.background = 'color-mix(in oklab, var(--warn) 12%, var(--panel))';
          buttonArea.style.borderColor = 'color-mix(in oklab, var(--warn) 40%, var(--border))';
        }
        
        if (okButton) {
          okButton.style.background = 'var(--warn)';
          okButton.style.color = 'white';
          okButton.style.border = 'none';
        }
        
        if (cancelButton) {
          cancelButton.style.borderColor = 'color-mix(in oklab, var(--warn) 30%, var(--border))';
        }
        
        // Fade-in animation
        if (panel) {
          panel.style.opacity = '0';
          panel.style.transform = 'scale(0.95) translateY(-6px)';
          panel.style.transition = 'opacity 0.25s ease, transform 0.25s ease';
          requestAnimationFrame(() => {
            panel.style.opacity = '1';
            panel.style.transform = 'scale(1) translateY(0)';
          });
        }
      });
    }
    
    // show a non-blocking shutdown message that auto-dismisses and closes the tab
    function showShutdownMessage() {
      // create a nice shutdown overlay
      const shutdownOverlay = document.createElement('div');
      shutdownOverlay.id = 'shutdownOverlay';
      shutdownOverlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(11, 15, 20, 0.95);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 99999;
        opacity: 0;
        transition: opacity 0.3s ease-in;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial;
      `;
      
      shutdownOverlay.innerHTML = `
        <div style="
          text-align: center;
          padding: 40px;
          max-width: 500px;
          color: var(--text);
        ">
          <div style="
            font-size: 48px;
            margin-bottom: 24px;
            animation: fadeInScale 0.4s ease-out;
            display: flex;
            align-items: center;
            justify-content: center;
          "><img src="/static/assets/goodbye.svg" alt="" style="width:92px; height:92px;" /></div>
          <h1 style="
            font-size: 28px;
            font-weight: 600;
            margin: 0 0 12px 0;
            color: var(--text);
            animation: fadeInUp 0.5s ease-out 0.1s both;
          ">Thank you for using CustosEye</h1>
          <p style="
            font-size: 16px;
            color: var(--muted);
            margin: 0;
            line-height: 1.6;
            animation: fadeInUp 0.5s ease-out 0.2s both;
          ">Shutting down safely...</p>
        </div>
      `;
      
      // add keyframe animations
      const style = document.createElement('style');
      style.textContent = `
        @keyframes fadeInScale {
          from {
            opacity: 0;
            transform: scale(0.8);
          }
          to {
            opacity: 1;
            transform: scale(1);
          }
        }
        @keyframes fadeInUp {
          from {
            opacity: 0;
            transform: translateY(10px);
          }
          to {
            opacity: 1;
            transform: translateY(0);
          }
        }
      `;
      document.head.appendChild(style);
      
      document.body.appendChild(shutdownOverlay);
      
      // fade in
      requestAnimationFrame(() => {
        shutdownOverlay.style.opacity = '1';
      });
      
      // after 1.5 seconds, close the tab
      setTimeout(() => {
        // try to close the window/tab (only closes the current tab/window, not other tabs)
        // window.close() is safe - it only closes the current window/tab, never other tabs
        window.close();
        
        // if window.close() does not work (browser blocked it), show fallback message
        setTimeout(() => {
          // change background to plain color (no dashboard visible)
          shutdownOverlay.style.background = 'var(--bg)';
          shutdownOverlay.innerHTML = `
            <div style="
              text-align: center;
              padding: 40px;
              max-width: 500px;
              color: var(--text);
            ">
              <div style="
                font-size: 48px;
                margin-bottom: 24px;
              ">✓</div>
              <h1 style="
                font-size: 24px;
                font-weight: 600;
                margin: 0 0 12px 0;
                color: var(--text);
              ">CustosEye has been shut down</h1>
              <p style="
                font-size: 14px;
                color: var(--muted);
                margin: 0 0 8px 0;
                line-height: 1.6;
              ">You can safely close this tab now.</p>
              <p style="
                font-size: 20px;
                color: var(--muted);
                margin: 96px 0 0 0;
                line-height: 1.6;
              ">:･ﾟ✧:･.☽˚｡ ⋆｡˚✧</p>
            </div>
          `;
        }, 300);
      }, 1500);
    }
    
    // logout button: sign out and optionally shutdown the program
    document.getElementById('logoutBtn')?.addEventListener('click', async () => {
      const action = await showLogoutDialog('What would you like to do?');
      
      if (action === 'cancel') {
        // user cancelled, stay on dashboard
        return;
      }
      
      try {
        const res = await fetch('/auth/logout', {
          method: 'POST',
          headers: {'Content-Type': 'application/json'},
          body: JSON.stringify({ shutdown: action === 'shutdown' })
        });
        const result = await res.json();
        if (result.success) {
          if (action === 'shutdown' || result.shutdown) {
            // show nice shutdown message that auto-dismisses and closes tab
            showShutdownMessage();
          } else if (result.redirect) {
            window.location.href = result.redirect;
          } else {
            window.location.href = '/auth/login';
          }
        }
      } catch (err) {
        // if logout fails but it was a shutdown, show message and close
        if (action === 'shutdown') {
          showShutdownMessage();
        } else {
          console.error('Logout error:', err);
          // if logout fails, just redirect anyway
          window.location.href = '/auth/login';
        }
      }
    });
  </script>
</body>
</html>