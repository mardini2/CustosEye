<!--
  goal: methodology page for CustosEye website. explains how CustosEye works in plain language,
        covering what data it uses, how it processes that data, and what assumptions or limitations
        exist. kept straightforward and honest.
-->
<!doctype html>
<html lang="en">

<head>
  <!-- standard metadata -->
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- title -->
  <title>Methodology - CustosEye</title>

  <!-- SEO and structured metadata -->
  <meta name="description" content="Learn how CustosEye works - what data it uses, how it processes information, and its approach to local-first security monitoring." />
  <meta name="robots" content="index, follow" />
  <link rel="canonical" href="https://www.custoseye.com/methodology.html" />

  <!-- Open Graph (social preview) -->
  <meta property="og:title" content="Methodology - CustosEye" />
  <meta property="og:description" content="Learn how CustosEye works - local-first security monitoring methodology." />
  <meta property="og:url" content="https://www.custoseye.com/methodology.html" />
  <meta property="og:type" content="website" />
  <meta property="og:image" content="https://www.custoseye.com/assets/favicon.png" />

  <!-- Favicon -->
  <link rel="icon" href="https://www.custoseye.com/assets/favicon.png" type="image/png" />
  <link rel="icon" href="assets/favicon.ico?v=2" sizes="any" />

  <!-- shared styles -->
  <link rel="stylesheet" href="styles.css?v=2" />
  <link rel="preload" href="styles.css?v=2" as="style" />
</head>

<body class="page">
  <!-- a slim royal-purple stripe for subtle branding -->
  <div class="top-stripe" aria-hidden="true"></div>

  <!-- header: logo + brand + navigation -->
  <header class="topbar">
    <!-- logo links home -->
    <a class="home-link" href="/" aria-label="Go to homepage">
      <img class="logo" src="assets/favicon.png" alt="CustosEye logo" />
    </a>

    <!-- brand (title + tagline) links home -->
    <a class="home-link brand" href="/" aria-label="Go to homepage">
      <h1>CustosEye</h1>
      <p class="tagline">Your Third Eye</p>
    </a>

    <!-- main navigation: primary site sections only -->
    <nav class="topbar-nav" role="menubar" aria-label="Main navigation">
      <a href="index.html" role="menuitem">Home</a>
      <span class="nav-sep">|</span>
      <div class="nav-has-submenu">
        <a href="#" role="menuitem" aria-haspopup="true" aria-expanded="false" id="about-menu-button" tabindex="0">About</a>
        <div class="nav-submenu" role="menu" aria-labelledby="about-menu-button">
          <a href="about.html" role="menuitem">About</a>
          <a href="methodology.html" role="menuitem" aria-current="page">Methodology</a>
          <a href="ethics.html" role="menuitem">Code of Ethics</a>
        </div>
      </div>
      <span class="nav-sep">|</span>
      <a href="download.html" role="menuitem">Downloads</a>
      <span class="nav-sep">|</span>
      <a href="documentation.html" role="menuitem">Documentation</a>
    </nav>
  </header>

  <!-- main content -->
  <main class="wrap">
    <!-- methodology section: how CustosEye works -->
    <section class="card">
      <h2 style="margin-bottom: 16px">Methodology</h2>

      <p style="margin-bottom: 16px; line-height: 1.6;">
        This page explains how CustosEye works: what data it collects, how it processes that data,
        and what assumptions or limitations you should be aware of.
      </p>

      <h3 style="margin-top: 24px; margin-bottom: 12px; font-size: 1.2rem;">Purpose and Goals</h3>
      <p style="margin-bottom: 16px; line-height: 1.6;">
        CustosEye is designed to give you visibility into what's happening on your system without
        requiring cloud services or sending data anywhere. It monitors processes, network activity,
        and file integrity, then presents this information in a simple web dashboard so you can
        understand what's running and what's changed.
      </p>

      <h3 style="margin-top: 24px; margin-bottom: 12px; font-size: 1.2rem;">What Data CustosEye Uses</h3>
      <p style="margin-bottom: 16px; line-height: 1.6;">
        CustosEye collects three types of data from your system:
      </p>
      <ul style="margin-bottom: 16px; line-height: 1.8; padding-left: 20px;">
        <li><strong>Process information:</strong> running processes, their executable paths, file hashes,
          code signatures, parent processes, and whether they're running as services or with elevated privileges</li>
        <li><strong>Network activity:</strong> listening ports, active network connections, and which processes
          are making connections</li>
        <li><strong>File integrity data:</strong> for files you choose to monitor, CustosEye computes SHA-256
          hashes or tracks modification time and size to detect changes</li>
      </ul>
      <p style="margin-bottom: 16px; line-height: 1.6;">
        All of this data stays on your machine. Nothing is sent to external servers or cloud services.
      </p>

      <h3 style="margin-top: 24px; margin-bottom: 12px; font-size: 1.2rem;">How Data is Processed</h3>
      <p style="margin-bottom: 16px; line-height: 1.6;">
        CustosEye processes data in several stages:
      </p>

      <h4 style="margin-top: 20px; margin-bottom: 10px; font-size: 1.05rem;">1. Collection</h4>
      <p style="margin-bottom: 16px; line-height: 1.6;">
        Three monitoring agents run continuously in the background, publishing events to an event bus:
      </p>
      <ul style="margin-bottom: 16px; line-height: 1.8; padding-left: 20px;">
        <li><strong>Process monitor:</strong> Scans running processes periodically, tracking executable paths, file hashes, code signatures, parent processes, memory usage, command lines, and whether processes are running as services or with elevated privileges</li>
        <li><strong>Network scanner:</strong> Captures listening ports and active network connections, identifying which processes are making connections</li>
        <li><strong>Integrity checker:</strong> Compares watched files against their baseline hashes (SHA-256) or metadata (mtime+size) every split second for faster detection</li>
      </ul>

      <h4 style="margin-top: 20px; margin-bottom: 10px; font-size: 1.05rem;">2. Trust Scoring (CSC v2)</h4>
      <p style="margin-bottom: 16px; line-height: 1.6;">
        Each process is evaluated using a trust scoring engine (CSC v2) that considers multiple signals:
      </p>
      <ul style="margin-bottom: 16px; line-height: 1.8; padding-left: 20px;">
        <li><strong>Path context:</strong> System directories are trusted, temp/downloads are suspicious</li>
        <li><strong>Code signing:</strong> Valid signatures boost trust, especially from known publishers</li>
        <li><strong>Name heuristics:</strong> High entropy names, hex-like strings, misspellings of system processes reduce trust</li>
        <li><strong>File characteristics:</strong> Very new or tiny binaries outside system dirs are flagged</li>
        <li><strong>Network behavior:</strong> Listening on ports (especially risky ones) is suspicious</li>
        <li><strong>Parent context:</strong> Processes launched by script interpreters get penalized</li>
        <li><strong>Elevation/service:</strong> Elevated processes or services from user directories are highly suspicious</li>
        <li><strong>Prevalence:</strong> Processes seen frequently on your machine earn trust over time (with time decay)</li>
      </ul>
      <p style="margin-bottom: 16px; line-height: 1.6;">
        These signals are combined into a score, which is then mapped to a categorical verdict:
        <strong>trusted</strong>, <strong>caution</strong>, <strong>suspicious</strong>, <strong>malicious</strong>, or <strong>unknown</strong>.
        The engine also assigns a class (like "system", "service", "dev_tool", "game", "utility") to help categorize processes.
        The engine produces confidence scores and human-readable reasons for each verdict.
      </p>

      <h4 style="margin-top: 20px; margin-bottom: 10px; font-size: 1.05rem;">3. Rules Engine</h4>
      <p style="margin-bottom: 16px; line-height: 1.6;">
        The rules engine (<code style="background: rgba(0,0,0,0.3); padding: 2px 6px; border-radius: 4px;">data/rules.json</code>)
        applies severity levels (Info, Warning, Critical) and contextual reasons to events. Rules are evaluated in order, the first match wins.
        Rules can match on:
      </p>
      <ul style="margin-bottom: 16px; line-height: 1.8; padding-left: 20px;">
        <li>Source type (process, network, integrity)</li>
        <li>Process names or executable paths</li>
        <li>Listening ports</li>
        <li>Remote connections</li>
        <li>And more</li>
      </ul>
      <p style="margin-bottom: 16px; line-height: 1.6;">
        Rules hot-reload automatically when you edit the file. The engine also deduplicates events within a short window
        to reduce noise while preserving important state changes.
      </p>

      <h4 style="margin-top: 20px; margin-bottom: 10px; font-size: 1.05rem;">4. Event Processing and Storage</h4>
      <p style="margin-bottom: 16px; line-height: 1.6;">
        The dashboard subscribes to the event bus and processes events in a background thread. Events get:
      </p>
      <ul style="margin-bottom: 16px; line-height: 1.8; padding-left: 20px;">
        <li>Tagged with severity levels by the rules engine</li>
        <li>Scored by the CSC trust engine (for process events)</li>
        <li>Deduplicated to reduce noise</li>
        <li>Stored in a ring buffer (oldest events drop when full)</li>
      </ul>
      <p style="margin-bottom: 16px; line-height: 1.6;">
        For file integrity events, the dashboard computes diffs when changes are detected. It uses chunk-based hashing
        to find what changed, extracts text from various file types (text files, Office documents, PDFs), and performs
        character/word/line-level diffs. Baseline storage optionally stores full file snapshots, auto-pruning to stay
        under size limits.
      </p>

      <h4 style="margin-top: 20px; margin-bottom: 10px; font-size: 1.05rem;">5. Presentation</h4>
      <p style="margin-bottom: 16px; line-height: 1.6;">
        Processed events are displayed in the web dashboard (accessible at <code style="background: rgba(0,0,0,0.3); padding: 2px 6px; border-radius: 4px;">http://127.0.0.1:8765/</code>
        with authentication required). The dashboard includes:
      </p>
      <ul style="margin-bottom: 16px; line-height: 1.8; padding-left: 20px;">
        <li><strong>Live Events tab:</strong> Real-time stream with filters by level (Info, Warning, Critical), search by process name or path, pause/resume, and export to CSV, JSON, JSONL, or XLSX</li>
        <li><strong>Process Tree tab:</strong> Hierarchical view of all running processes showing parent-child relationships, trust verdicts, and process classes. Search and expand/collapse nodes</li>
        <li><strong>Integrity tab:</strong> Manage files you want to monitor, add files with SHA-256 or mtime+size rules, view diffs when changes are detected</li>
        <li><strong>About tab:</strong> Version information, build details, buffer size, and runtime stats</li>
      </ul>

      <!-- architecture diagram with zoom and pan -->
      <div style="margin-top: 24px; margin-bottom: 16px;">
        <div style="background: rgba(0,0,0,0.2); border-radius: 8px; border: 1px solid rgba(255,255,255,0.1); overflow: hidden;">
          <!-- controls -->
          <div style="padding: 12px 16px; background: rgba(0,0,0,0.3); border-bottom: 1px solid rgba(255,255,255,0.1); display: flex; align-items: center; gap: 12px; flex-wrap: wrap;">
            <span style="color: #9aa3b2; font-size: 0.9rem; margin-right: auto;">Architecture Diagram:</span>
            <button id="zoom-in-btn" style="background: rgba(139, 92, 246, 0.2); border: 1px solid rgba(139, 92, 246, 0.4); color: #e5e7eb; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 0.9rem; transition: background 0.2s;" onmouseover="this.style.background='rgba(139, 92, 246, 0.3)'" onmouseout="this.style.background='rgba(139, 92, 246, 0.2)'">Zoom In</button>
            <button id="zoom-out-btn" style="background: rgba(139, 92, 246, 0.2); border: 1px solid rgba(139, 92, 246, 0.4); color: #e5e7eb; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 0.9rem; transition: background 0.2s;" onmouseover="this.style.background='rgba(139, 92, 246, 0.3)'" onmouseout="this.style.background='rgba(139, 92, 246, 0.2)'">Zoom Out</button>
            <button id="reset-zoom-btn" style="background: rgba(139, 92, 246, 0.2); border: 1px solid rgba(139, 92, 246, 0.4); color: #e5e7eb; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 0.9rem; transition: background 0.2s;" onmouseover="this.style.background='rgba(139, 92, 246, 0.3)'" onmouseout="this.style.background='rgba(139, 92, 246, 0.2)'">Reset</button>
            <span id="zoom-level" style="color: #9aa3b2; font-size: 0.85rem; min-width: 60px; text-align: right;">100%</span>
          </div>
          <!-- SVG container -->
          <div id="svg-container" style="position: relative; width: 100%; height: 600px; overflow: hidden; background: rgb(35, 32, 48); cursor: grab; touch-action: none;" onmousedown="handleMouseDown(event)" onmousemove="handleMouseMove(event)" onmouseup="handleMouseUp(event)" onmouseleave="handleMouseUp(event)" onwheel="handleWheel(event)">
            <div id="svg-wrapper" style="position: absolute; top: 0; left: 0; transform-origin: 0 0;">
              <object id="architecture-svg" data="assets/custoseye-architecture.svg" type="image/svg+xml" width="6928" height="1683" style="display: block; max-width: none; pointer-events: none;">
                <p style="color: #9aa3b2; padding: 20px; text-align: center;">Unable to load architecture diagram. Please check that the file exists.</p>
              </object>
            </div>
          </div>
          <div style="padding: 8px 16px; background: rgba(0,0,0,0.2); border-top: 1px solid rgba(255,255,255,0.1);">
            <p style="margin: 0; color: #9aa3b2; font-size: 0.85rem; text-align: center;">
              Use mouse wheel to zoom, click and drag to pan. Shows data flow: Collection → Trust Scoring → Rules Engine → Event Processing → Dashboard
            </p>
          </div>
        </div>
      </div>

      <h3 style="margin-top: 24px; margin-bottom: 12px; font-size: 1.2rem;">Assumptions and Limitations</h3>
      <p style="margin-bottom: 16px; line-height: 1.6;">
        CustosEye makes several assumptions and has known limitations:
      </p>
      <ul style="margin-bottom: 16px; line-height: 1.8; padding-left: 20px;">
        <li><strong>Local-only operation:</strong> CustosEye doesn't use threat intelligence feeds or
          cloud-based reputation services. Trust scores are based entirely on local signals and your
          system's history.</li>
        <li><strong>Heuristic-based scoring:</strong> The trust scoring engine uses heuristics and local
          prevalence, not behavioral analysis or machine learning. It's designed to be fast and explainable,
          but may miss sophisticated threats that don't match known patterns.</li>
        <li><strong>No real-time blocking:</strong> CustosEye is a monitoring tool, not an active security
          product. It reports what it sees but doesn't block or quarantine processes.</li>
        <li><strong>Windows focus:</strong> Currently designed for Windows 10 or 11. Process and network
          monitoring uses Windows-specific APIs and may not work on other platforms.</li>
        <li><strong>File integrity modes:</strong> The "mtime+size" mode is faster but less secure than
          SHA-256 hashing. It might miss changes that don't affect file size or modification time.</li>
        <li><strong>Prevalence learning:</strong> The trust engine learns from what it sees on your machine,
          but this means it may be less accurate on a fresh system or when new software is first installed.</li>
      </ul>

      <h3 style="margin-top: 24px; margin-bottom: 12px; font-size: 1.2rem;">Privacy and Data Handling</h3>
      <p style="margin-bottom: 16px; line-height: 1.6;">
        All data collected by CustosEye stays on your machine. No information is sent to external servers.
        The dashboard runs locally on your computer, and all processing happens in memory or in local files.
        For more details on privacy and data handling, see our <a href="privacy.html" style="color: #8b5cf6;">Privacy Policy</a>.
      </p>
    </section>
  </main>

  <!-- footer: legal and consent links -->
  <footer class="foot">
    <nav class="foot-nav">
      <!-- cookie settings link goes to cookies page -->
      <a href="cookies.html">Cookie Settings</a>
      <a href="privacy.html">Privacy Policy</a>
      <a href="license.html">License</a>
    </nav>
    <small class="muted">© <span id="year"></span> CustosEye. All rights reserved.</small>
  </footer>

  <!-- set current year in footer -->
  <script>
    document.getElementById('year').textContent = new Date().getFullYear();
  </script>

  <!-- navigation accessibility and keyboard support -->
  <script src="js/nav-accessibility.js?v=2"></script>

  <!-- Cookie banner (shows once until a choice is stored) -->
  <script src="js/consent.js?v=2"></script>

  <!-- GA attaches only after consent -->
  <script src="js/analytics-attach.js?v=2" defer></script>

  <!-- SVG zoom and pan functionality -->
  <script>
    (function() {
      let scale = 1;
      let panX = 0;
      let panY = 0;
      let initialScale = 1;
      let initialPanX = 0;
      let initialPanY = 0;
      let svgWidth = 6928.32;  // Store SVG dimensions
      let svgHeight = 1683;
      let isDragging = false;
      let startX = 0;
      let startY = 0;
      let startPanX = 0;
      let startPanY = 0;
      const minScale = 0.1;
      const maxScale = 5;
      const zoomStep = 0.1;

      const container = document.getElementById('svg-container');
      const wrapper = document.getElementById('svg-wrapper');
      const svgImg = document.getElementById('architecture-svg');
      const zoomLevel = document.getElementById('zoom-level');
      const zoomInBtn = document.getElementById('zoom-in-btn');
      const zoomOutBtn = document.getElementById('zoom-out-btn');
      const resetBtn = document.getElementById('reset-zoom-btn');

      function constrainPan() {
        const containerRect = container.getBoundingClientRect();
        const containerWidth = containerRect.width;
        const containerHeight = containerRect.height;
        
        // Calculate scaled dimensions
        const scaledWidth = svgWidth * scale;
        const scaledHeight = svgHeight * scale;
        
        // Calculate bounds - ensure at least 20% of the diagram is always visible
        const minVisibleRatio = 0.2;
        const maxPanX = containerWidth - (scaledWidth * minVisibleRatio);
        const minPanX = -(scaledWidth * (1 - minVisibleRatio));
        const maxPanY = containerHeight - (scaledHeight * minVisibleRatio);
        const minPanY = -(scaledHeight * (1 - minVisibleRatio));
        
        // If diagram is smaller than container, center it
        if (scaledWidth <= containerWidth) {
          panX = (containerWidth - scaledWidth) / 2;
        } else {
          panX = Math.max(minPanX, Math.min(maxPanX, panX));
        }
        
        if (scaledHeight <= containerHeight) {
          panY = (containerHeight - scaledHeight) / 2;
        } else {
          panY = Math.max(minPanY, Math.min(maxPanY, panY));
        }
      }

      function updateTransform(smooth = false) {
        constrainPan();
        // Remove transition during dragging for smooth movement
        if (!smooth || isDragging) {
          wrapper.style.transition = 'none';
        } else {
          wrapper.style.transition = 'transform 0.1s';
        }
        wrapper.style.transform = `translate(${panX}px, ${panY}px) scale(${scale})`;
        zoomLevel.textContent = Math.round(scale * 100) + '%';
      }

      function initializeView() {
        // Set up immediately with known dimensions (from viewBox: 6928.32 x 1683)
        // This ensures the diagram is visible right away
        setupInitialView();
        
        // Also try to update when object loads (in case we can get better dimensions)
        svgImg.addEventListener('load', function() {
          setTimeout(setupInitialView, 100);
        });
      }

      function setupInitialView() {
        const containerRect = container.getBoundingClientRect();
        const containerWidth = containerRect.width;
        const containerHeight = containerRect.height;
        
        // Try to get dimensions from object's SVG content
        let imgWidth = 6928.32; // Default from viewBox
        let imgHeight = 1683;   // Default from viewBox
        
        try {
          if (svgImg.contentDocument) {
            const svgDoc = svgImg.contentDocument;
            const svgElement = svgDoc.querySelector('svg');
            if (svgElement) {
              const viewBox = svgElement.getAttribute('viewBox');
              if (viewBox) {
                const parts = viewBox.split(/\s+/);
                if (parts.length >= 4) {
                  imgWidth = parseFloat(parts[2]) || imgWidth;
                  imgHeight = parseFloat(parts[3]) || imgHeight;
                }
              }
              // Also try width/height attributes
              if (svgElement.hasAttribute('width') && svgElement.hasAttribute('height')) {
                const w = parseFloat(svgElement.getAttribute('width'));
                const h = parseFloat(svgElement.getAttribute('height'));
                if (w > 0 && h > 0) {
                  imgWidth = w;
                  imgHeight = h;
                }
              }
            }
          }
        } catch (e) {
          // CORS or other error, use defaults
          console.log('Using default SVG dimensions');
        }
        
        // Store dimensions globally
        svgWidth = imgWidth;
        svgHeight = imgHeight;
        
        // Calculate scale to fit with some padding (5% margin)
        const scaleX = (containerWidth * 0.95) / imgWidth;
        const scaleY = (containerHeight * 0.95) / imgHeight;
        initialScale = Math.min(scaleX, scaleY, 1); // Don't scale up beyond 100%
        
        // Center the image
        const scaledWidth = imgWidth * initialScale;
        const scaledHeight = imgHeight * initialScale;
        initialPanX = (containerWidth - scaledWidth) / 2;
        initialPanY = (containerHeight - scaledHeight) / 2;
        
        scale = initialScale;
        panX = initialPanX;
        panY = initialPanY;
        
        updateTransform(true);
      }

      function zoomAtPoint(delta, clientX, clientY) {
        const rect = container.getBoundingClientRect();
        const x = clientX - rect.left;
        const y = clientY - rect.top;
        
        const oldScale = scale;
        scale += delta;
        scale = Math.max(minScale, Math.min(maxScale, scale));
        
        if (scale !== oldScale) {
          const scaleChange = scale / oldScale;
          panX = x - (x - panX) * scaleChange;
          panY = y - (y - panY) * scaleChange;
          updateTransform(true);
        }
      }

      function resetZoom() {
        scale = initialScale;
        panX = initialPanX;
        panY = initialPanY;
        updateTransform(true);
      }

      // Mouse wheel zoom
      window.handleWheel = function(e) {
        e.preventDefault();
        const delta = e.deltaY > 0 ? -zoomStep : zoomStep;
        zoomAtPoint(delta, e.clientX, e.clientY);
      };

      // Mouse drag pan
      window.handleMouseDown = function(e) {
        if (e.button === 0) { // Left mouse button
          isDragging = true;
          startX = e.clientX;
          startY = e.clientY;
          startPanX = panX;
          startPanY = panY;
          container.style.cursor = 'grabbing';
        }
      };

      window.handleMouseMove = function(e) {
        if (isDragging) {
          panX = startPanX + (e.clientX - startX);
          panY = startPanY + (e.clientY - startY);
          updateTransform(false); // No smooth transition during drag
        }
      };

      window.handleMouseUp = function(e) {
        isDragging = false;
        container.style.cursor = 'grab';
      };

      // Button controls
      zoomInBtn.addEventListener('click', function() {
        const rect = container.getBoundingClientRect();
        zoomAtPoint(zoomStep, rect.left + rect.width / 2, rect.top + rect.height / 2);
      });

      zoomOutBtn.addEventListener('click', function() {
        const rect = container.getBoundingClientRect();
        zoomAtPoint(-zoomStep, rect.left + rect.width / 2, rect.top + rect.height / 2);
      });

      resetBtn.addEventListener('click', resetZoom);

      // Touch support for mobile
      let touchStartDistance = 0;
      let touchStartScale = 1;
      let touchStartPanX = 0;
      let touchStartPanY = 0;
      let touchStartCenterX = 0;
      let touchStartCenterY = 0;

      container.addEventListener('touchstart', function(e) {
        if (e.touches.length === 1) {
          isDragging = true;
          startX = e.touches[0].clientX;
          startY = e.touches[0].clientY;
          startPanX = panX;
          startPanY = panY;
        } else if (e.touches.length === 2) {
          isDragging = false;
          const touch1 = e.touches[0];
          const touch2 = e.touches[1];
          touchStartDistance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY);
          touchStartScale = scale;
          touchStartPanX = panX;
          touchStartPanY = panY;
          touchStartCenterX = (touch1.clientX + touch2.clientX) / 2;
          touchStartCenterY = (touch1.clientY + touch2.clientY) / 2;
        }
      }, { passive: false });

      container.addEventListener('touchmove', function(e) {
        e.preventDefault();
        if (e.touches.length === 1 && isDragging) {
          panX = startPanX + (e.touches[0].clientX - startX);
          panY = startPanY + (e.touches[0].clientY - startY);
          updateTransform(false); // No smooth transition during drag
        } else if (e.touches.length === 2) {
          const touch1 = e.touches[0];
          const touch2 = e.touches[1];
          const distance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY);
          const scaleChange = distance / touchStartDistance;
          scale = Math.max(minScale, Math.min(maxScale, touchStartScale * scaleChange));
          
          const centerX = (touch1.clientX + touch2.clientX) / 2;
          const centerY = (touch1.clientY + touch2.clientY) / 2;
          const rect = container.getBoundingClientRect();
          const x = centerX - rect.left;
          const y = centerY - rect.top;
          
          panX = x - (x - touchStartPanX) * scale / touchStartScale;
          panY = y - (y - touchStartPanY) * scale / touchStartScale;
          updateTransform(false); // No smooth transition during pinch zoom
        }
      }, { passive: false });

      container.addEventListener('touchend', function(e) {
        isDragging = false;
      });

      // Initialize - wait for image to load and set up initial view
      initializeView();
      
      // Also handle window resize to recalculate initial view
      let resizeTimeout;
      window.addEventListener('resize', function() {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(function() {
          setupInitialView();
        }, 250);
      });
    })();
  </script>
</body>
</html>